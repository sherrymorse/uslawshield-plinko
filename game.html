<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>U.S. LawShield PLINKO</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  :root {
    --seahawks-navy: #002244;
    --seahawks-green: #69BE28;
    --seahawks-blue: #245998;
    --accent-gold: #FFD700;
    --accent-orange: #FF8C00;
  }
  
  body {
    font-family: 'Montserrat', sans-serif;
    background: linear-gradient(135deg, var(--seahawks-navy) 0%, var(--seahawks-blue) 50%, var(--seahawks-navy) 100%);
    min-height: 100vh;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .game-container {
    max-width: 850px;
    width: 100%;
  }

  .header {
    text-align: center;
    padding: 20px;
    margin-bottom: 20px;
  }

  .title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3.5em;
    letter-spacing: 6px;
    text-shadow: 0 0 30px var(--accent-gold), 3px 3px 0 #000;
    color: white;
    margin-bottom: 5px;
  }

  .subtitle {
    font-size: 1.2em;
    letter-spacing: 3px;
    color: var(--accent-gold);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    font-weight: 800;
  }

  .canvas-wrapper {
    position: relative;
    border-radius: 20px;
    overflow: hidden;
    box-shadow: 0 0 60px rgba(105, 190, 40, 0.6);
    border: 6px solid var(--accent-gold);
    background: linear-gradient(135deg, #001933 0%, #003366 100%);
  }

  #plinkoCanvas {
    display: block;
    width: 100%;
    background: linear-gradient(135deg, #001933 0%, #003366 100%);
  }

  .game-info {
    position: absolute;
    top: 20px;
    left: 20px;
    right: 20px;
    display: flex;
    justify-content: space-between;
    z-index: 10;
  }

  .info-badge {
    background: linear-gradient(135deg, var(--seahawks-navy) 0%, var(--seahawks-blue) 100%);
    padding: 10px 20px;
    border-radius: 20px;
    border: 3px solid var(--accent-gold);
    color: var(--accent-gold);
    font-weight: 800;
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
  }

  .drop-zone-label {
    background: linear-gradient(135deg, var(--seahawks-green) 0%, #4A8A1F 100%);
    padding: 15px 30px;
    border-radius: 15px;
    font-size: 20px;
    font-weight: 800;
    box-shadow: 0 8px 25px rgba(105, 190, 40, 0.8);
    border: 4px solid var(--accent-gold);
    color: var(--seahawks-navy);
    text-align: center;
    margin-top: 15px;
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  .instruction {
    text-align: center;
    color: var(--accent-gold);
    font-weight: 700;
    font-size: 14px;
    margin-top: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .error-screen {
    text-align: center;
    padding: 40px;
    background: linear-gradient(135deg, rgba(0, 34, 68, 0.9) 0%, rgba(36, 89, 152, 0.9) 100%);
    border-radius: 25px;
    border: 4px solid var(--accent-gold);
    box-shadow: 0 15px 50px rgba(0,0,0,0.6);
  }

  .error-icon {
    font-size: 4em;
    margin-bottom: 20px;
  }

  .error-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 2.5em;
    color: var(--accent-gold);
    margin-bottom: 15px;
    letter-spacing: 3px;
  }

  .error-message {
    font-size: 1.2em;
    color: white;
    line-height: 1.6;
  }

  .release-warning {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 34, 68, 0.95);
    padding: 20px 30px;
    border-radius: 15px;
    border: 3px solid var(--accent-gold);
    color: var(--accent-gold);
    font-weight: 700;
    font-size: 16px;
    text-align: center;
    z-index: 100;
    box-shadow: 0 10px 30px rgba(0,0,0,0.8);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }

  .release-warning.show {
    opacity: 1;
  }

  .bigwin {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-size: 6em;
    color: var(--accent-gold);
    text-shadow: 0 0 50px var(--accent-gold), 0 0 100px var(--accent-orange);
    z-index: 9999;
    pointer-events: none;
    animation: win 2s forwards;
    font-family: 'Bebas Neue', sans-serif;
    letter-spacing: 6px;
  }

  @keyframes win {
    0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }
</style>
</head>
<body>
<div class="game-container" id="gameContainer">
  <div class="header">
    <h1 class="title">U.S. LAWSHIELD PLINKO</h1>
    <p class="subtitle">LEGAL DEFENSE FOR SELF DEFENSE®</p>
  </div>

  <div class="canvas-wrapper">
    <div class="game-info">
      <div class="info-badge" id="currentBoard">BOARD A</div>
      <div class="info-badge">PUCKS: <span id="puckCounter">0</span></div>
    </div>
    <canvas id="plinkoCanvas" width="800" height="1000"></canvas>
    <div class="release-warning" id="releaseWarning">
      ⚠️ Return to drop zone to release puck!
    </div>
  </div>

  <div class="drop-zone-label">DROP ZONE</div>
  <div class="instruction">HOVER PUCK → CLICK & HOLD → POSITION → RELEASE TO DROP!</div>
</div>

<script>
const JSONBIN_CONFIG = {
  MASTER_KEY: '$2a$10$NckuWO.y9g8.amyZZWkc8.lKIMS.AVSCyN1qT9/0d5EtRjuV9lmS2',
  BASE_URL: 'https://api.jsonbin.io/v3/b',
  HEADERS: {
    'Content-Type': 'application/json',
    'X-Master-Key': '$2a$10$NckuWO.y9g8.amyZZWkc8.lKIMS.AVSCyN1qT9/0d5EtRjuV9lmS2'
  }
};

// Check for game parameter
const urlParams = new URLSearchParams(window.location.search);
const gameId = urlParams.get('game');

if (!gameId) {
  showError();
} else {
  initGame(gameId);
}

function showError() {
  document.getElementById('gameContainer').innerHTML = `
    <div class="error-screen">
      <div class="error-icon">⚠️</div>
      <h2 class="error-title">INVALID SESSION</h2>
      <p class="error-message">
        This game link is invalid or has expired.<br>
        Please contact the administrator for a new game link.
      </p>
    </div>
  `;
}

async function initGame(binId) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`, {
      headers: { 'X-Master-Key': JSONBIN_CONFIG.HEADERS['X-Master-Key'] }
    });
    
    if (!response.ok) throw new Error('Failed to load game');
    
    const data = await response.json();
    const gameState = data.record;
    
    // Mark player as connected
    gameState.playerConnected = true;
    await updateGameBin(binId, gameState);
    
    // Start game
    startPlinko(binId, gameState);
    
  } catch (error) {
    console.error('Error loading game:', error);
    showError();
  }
}

async function updateGameBin(binId, data) {
  await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}`, {
    method: 'PUT',
    headers: JSONBIN_CONFIG.HEADERS,
    body: JSON.stringify({ ...data, lastUpdated: Date.now() })
  });
}

async function readGameBin(binId) {
  const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`, {
    headers: { 'X-Master-Key': JSONBIN_CONFIG.HEADERS['X-Master-Key'] }
  });
  const data = await response.json();
  return data.record;
}

function startPlinko(binId, gameState) {
  const canvas = document.getElementById('plinkoCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const DROP_ZONE_HEIGHT = 120;
  const PUCK_RADIUS = 18;
  const PEG_RADIUS = 6;
  const NUM_ROWS = 20;
  const NUM_SLOTS = 9;

  let pegs = [];
  let currentPuck = null;
  let dragging = false;
  let hoverPuck = { x: W/2, y: DROP_ZONE_HEIGHT/2 };
  let animationId = null;
  let particles = [];
  let syncInterval = null;

  // Initialize pegs
  function initPegs() {
    pegs = [];
    const startY = DROP_ZONE_HEIGHT + 60;
    const rowHeight = (H - 160 - startY) / NUM_ROWS;
    const colSpacing = W / 8;
    
    for (let row = 0; row < NUM_ROWS; row++) {
      const numCols = row % 2 === 0 ? 9 : 8;
      const offset = row % 2 === 0 ? 0 : colSpacing / 2;
      
      for (let col = 0; col < numCols; col++) {
        pegs.push({
          x: offset + col * colSpacing,
          y: startY + row * rowHeight
        });
      }
    }
  }

  function drawBoard() {
    // Clear canvas
    const bgGradient = ctx.createLinearGradient(0, 0, 0, H);
    bgGradient.addColorStop(0, '#001933');
    bgGradient.addColorStop(1, '#003366');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, W, H);
    
    // Draw drop zone
    const dropGradient = ctx.createLinearGradient(0, 0, 0, DROP_ZONE_HEIGHT);
    dropGradient.addColorStop(0, '#69BE28');
    dropGradient.addColorStop(1, '#2D5F1D');
    ctx.fillStyle = dropGradient;
    ctx.fillRect(0, 0, W, DROP_ZONE_HEIGHT);
    ctx.strokeStyle = '#002244';
    ctx.lineWidth = 6;
    ctx.strokeRect(0, 0, W, DROP_ZONE_HEIGHT);
    
    // Draw pegs
    pegs.forEach(peg => {
      const pegGradient = ctx.createRadialGradient(peg.x - 3, peg.y - 3, 0, peg.x, peg.y, PEG_RADIUS);
      pegGradient.addColorStop(0, '#FFD700');
      pegGradient.addColorStop(0.7, '#FFA500');
      pegGradient.addColorStop(1, '#CC8400');
      
      ctx.fillStyle = pegGradient;
      ctx.beginPath();
      ctx.arc(peg.x, peg.y, PEG_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.shadowBlur = 0;
    });
    
    // Draw slots
    const currentBoard = gameState.boards[gameState.currentBoard];
    const slotHeight = 80;
    const slotWidth = W / NUM_SLOTS;
    
    currentBoard.prizes.forEach((prize, index) => {
      const slotGradient = ctx.createLinearGradient(index * slotWidth, H - slotHeight, index * slotWidth, H);
      slotGradient.addColorStop(0, prize.color);
      slotGradient.addColorStop(1, darkenColor(prize.color, 30));
      
      ctx.fillStyle = slotGradient;
      ctx.fillRect(index * slotWidth, H - slotHeight, slotWidth, slotHeight);
      
      ctx.strokeStyle = index === 4 ? '#FFD700' : '#69BE28';
      ctx.lineWidth = index === 4 ? 5 : 3;
      ctx.strokeRect(index * slotWidth, H - slotHeight, slotWidth, slotHeight);
      
      // Prize symbol (rotated)
      ctx.save();
      ctx.translate(index * slotWidth + slotWidth/2, H - slotHeight/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillStyle = 'white';
      ctx.font = 'bold 22px Montserrat';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if (index === 4) {
        ctx.shadowColor = '#FFD700';
        ctx.shadowBlur = 10;
      }
      ctx.fillText(prize.symbol, 0, 0);
      ctx.shadowBlur = 0;
      ctx.restore();
    });
    
    // Draw hover puck (if available and not dragging)
    if (gameState.pucksRemaining > 0 && !currentPuck && !dragging) {
      drawPuck(hoverPuck.x, hoverPuck.y);
    }
    
    // Draw current puck
    if (currentPuck) {
      drawPuck(currentPuck.x, currentPuck.y, currentPuck.rotation);
    }
    
    // Draw particles
    particles.forEach((particle, index) => {
      particle.life--;
      if (particle.life <= 0) {
        particles.splice(index, 1);
        return;
      }
      
      ctx.globalAlpha = particle.life / 60;
      ctx.fillStyle = particle.color;
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
  }

  function darkenColor(color, percent) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) - amt;
    const G = (num >> 8 & 0x00FF) - amt;
    const B = (num & 0x0000FF) - amt;
    return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                  (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                  (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  }

  function drawPuck(x, y, rotation = 0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    
    const puckGradient = ctx.createRadialGradient(-6, -6, 0, 0, 0, PUCK_RADIUS);
    puckGradient.addColorStop(0, '#FF6B6B');
    puckGradient.addColorStop(0.5, '#EE5A52');
    puckGradient.addColorStop(1, '#CC0000');
    
    ctx.fillStyle = puckGradient;
    ctx.beginPath();
    ctx.arc(0, 0, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#002244';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.fillStyle = '#002244';
    ctx.beginPath();
    ctx.arc(-6, -6, PUCK_RADIUS * 0.3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = 'white';
    ctx.font = 'bold 16px Montserrat';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('USL', 0, 0);
    
    ctx.restore();
  }

  function updatePhysics() {
    if (!currentPuck) return;
    
    currentPuck.vy += 0.5 + (Math.random() * 0.1);
    currentPuck.x += currentPuck.vx;
    currentPuck.y += currentPuck.vy;
    currentPuck.rotation += currentPuck.vx * 0.02;
    
    // Wall collisions
    if (currentPuck.x - PUCK_RADIUS < 0) {
      currentPuck.x = PUCK_RADIUS;
      currentPuck.vx = Math.abs(currentPuck.vx) * 0.75;
    } else if (currentPuck.x + PUCK_RADIUS > W) {
      currentPuck.x = W - PUCK_RADIUS;
      currentPuck.vx = -Math.abs(currentPuck.vx) * 0.75;
    }
    
    // Peg collisions
    pegs.forEach(peg => {
      const dx = currentPuck.x - peg.x;
      const dy = currentPuck.y - peg.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDistance = PUCK_RADIUS + PEG_RADIUS;
      
      if (distance < minDistance) {
        const angle = Math.atan2(dy, dx);
        currentPuck.x = peg.x + Math.cos(angle) * minDistance;
        currentPuck.y = peg.y + Math.sin(angle) * minDistance;
        
        const dot = currentPuck.vx * dx + currentPuck.vy * dy;
        currentPuck.vx -= 1.8 * dot * dx / (distance * distance);
        currentPuck.vy -= 1.8 * dot * dy / (distance * distance);
        
        currentPuck.vx += (Math.random() - 0.5) * 1.5;
        currentPuck.vy += (Math.random() - 0.5) * 1.5;
        currentPuck.rotation += currentPuck.vx * 0.05;
      }
    });
    
    // Check if reached bottom
    if (currentPuck.y + PUCK_RADIUS > H - 80) {
      const slotIndex = Math.floor(currentPuck.x / (W / NUM_SLOTS));
      const currentBoard = gameState.boards[gameState.currentBoard];
      const prize = currentBoard.prizes[slotIndex];
      
      // Award prize
      gameState.prizesWon.push({
        board: gameState.currentBoard,
        prize: prize.name,
        symbol: prize.symbol,
        timestamp: Date.now()
      });
      
      // Particles
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: currentPuck.x,
          y: H - 40,
          vx: (Math.random() - 0.5) * 12,
          vy: -Math.random() * 18,
          life: 80,
          size: Math.random() * 5 + 3,
          color: prize.color
        });
      }
      
      // Jackpot animation
      if (slotIndex === 4) {
        const winElement = document.createElement('div');
        winElement.className = 'bigwin';
        winElement.textContent = 'JACKPOT!';
        document.body.appendChild(winElement);
        setTimeout(() => winElement.remove(), 2500);
      }
      
      // Update state
      gameState.pucksRemaining--;
      
      // Check board switch
      if (gameState.boardType === 'BOTH' && gameState.currentBoard === 'A') {
        gameState.currentBoard = 'B';
        document.getElementById('currentBoard').textContent = 'BOARD B';
        initPegs();
      }
      
      currentPuck = null;
      updateDisplay();
      saveState();
      
      cancelAnimationFrame(animationId);
      drawBoard();
      return;
    }
    
    drawBoard();
    animationId = requestAnimationFrame(updatePhysics);
  }

  function animateHoverPuck() {
    if (currentPuck || gameState.pucksRemaining === 0) return;
    hoverPuck.x = W/2 + Math.sin(Date.now() * 0.002) * (W/2 - PUCK_RADIUS - 50);
    drawBoard();
    requestAnimationFrame(animateHoverPuck);
  }

  function updateDisplay() {
    document.getElementById('puckCounter').textContent = gameState.pucksRemaining;
    document.getElementById('currentBoard').textContent = `BOARD ${gameState.currentBoard}`;
  }

  async function saveState() {
    await updateGameBin(binId, gameState);
  }

  // Event handlers
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if (dragging && currentPuck) {
      currentPuck.x = Math.max(PUCK_RADIUS, Math.min(W - PUCK_RADIUS, x));
      currentPuck.y = Math.max(PUCK_RADIUS, Math.min(DROP_ZONE_HEIGHT - PUCK_RADIUS, y));
      drawBoard();
    } else if (gameState.pucksRemaining > 0 && !currentPuck) {
      hoverPuck.x = x;
      hoverPuck.y = y;
    }
  });

  canvas.addEventListener('mousedown', (e) => {
    if (currentPuck || gameState.pucksRemaining === 0) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const distance = Math.sqrt(Math.pow(x - hoverPuck.x, 2) + Math.pow(y - hoverPuck.y, 2));
    
    if (distance < PUCK_RADIUS * 1.5) {
      dragging = true;
      currentPuck = { x, y, vx: 0, vy: 0, rotation: 0 };
      gameState.puckGrabbed = true;
      saveState();
      drawBoard();
    }
  });

  canvas.addEventListener('mouseup', () => {
    if (dragging && currentPuck) {
      dragging = false;
      
      // Check if in drop zone
      if (currentPuck.y > DROP_ZONE_HEIGHT) {
        const warning = document.getElementById('releaseWarning');
        warning.classList.add('show');
        setTimeout(() => warning.classList.remove('show'), 2000);
        currentPuck = null;
        drawBoard();
        return;
      }
      
      const centerX = W / 2;
      currentPuck.vx = (currentPuck.x - centerX) * 0.5;
      currentPuck.vy = 2;
      
      animationId = requestAnimationFrame(updatePhysics);
      saveState();
    }
  });

  // Initialize
  initPegs();
  updateDisplay();
  drawBoard();
  animateHoverPuck();
  
  // Sync with server periodically
  syncInterval = setInterval(async () => {
    const remote = await readGameBin(binId);
    if (remote.pucksRemaining !== gameState.pucksRemaining) {
      gameState.pucksRemaining = remote.pucksRemaining;
      updateDisplay();
    }
  }, 3000);
}
</script>
</body>
</html>
