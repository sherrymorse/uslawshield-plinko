<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>U.S. LawShield PLINKO</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@700;800&display=swap" rel="stylesheet">
<style>
  * { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
  }
  
  body {
    font-family: 'Montserrat', sans-serif;
    background: #1a1a2e;
    min-height: 100vh;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    gap: 30px;
  }

  .side-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 280px;
  }

  .header {
    background: #FF1744;
    padding: 25px 20px;
    border: 6px solid #00BCD4;
    text-align: center;
  }

  .title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 2.5em;
    letter-spacing: 6px;
    color: white;
    text-shadow: 3px 3px 0 #000;
  }

  .subtitle {
    font-size: 0.9em;
    letter-spacing: 2px;
    margin-top: 8px;
    font-weight: 800;
  }

  .puck-holder {
    background: #FF1744;
    border: 6px solid #00BCD4;
    padding: 30px;
    text-align: center;
    min-height: 200px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
  }

  .puck-holder-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.8em;
    letter-spacing: 3px;
    color: white;
  }

  .puck-holder-canvas {
    cursor: grab;
  }

  .puck-holder-canvas:active {
    cursor: grabbing;
  }

  .info-badge {
    background: #FF1744;
    padding: 20px;
    border: 6px solid #00BCD4;
    color: white;
    font-weight: 800;
    font-size: 20px;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-align: center;
  }

  .legend-panel {
    background: #FF1744;
    border: 6px solid #00BCD4;
    padding: 20px;
    max-height: 500px;
    overflow-y: auto;
  }

  .legend-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.8em;
    color: white;
    margin-bottom: 15px;
    text-align: center;
    letter-spacing: 3px;
  }

  .prize-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px;
    margin-bottom: 8px;
    background: rgba(0, 0, 0, 0.2);
    border-left: 5px solid;
  }

  .prize-symbol {
    font-size: 1.8em;
    min-width: 35px;
    text-align: center;
  }

  .prize-name {
    font-size: 0.85em;
    font-weight: 700;
    line-height: 1.3;
    color: white;
  }

  .game-container {
    position: relative;
    width: 70vw;
    height: 70vh;
    max-width: 900px;
    max-height: 900px;
  }

  .canvas-wrapper {
    width: 100%;
    height: 100%;
    position: relative;
    background: #F5E6D3;
    border: 10px solid #FF1744;
    box-shadow: 0 0 0 4px #00BCD4, 0 0 0 8px white;
  }

  #plinkoCanvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  .game-info-top {
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    display: flex;
    justify-content: space-between;
    z-index: 10;
    pointer-events: none;
  }

  .top-badge {
    background: #FF1744;
    padding: 12px 20px;
    border: 4px solid white;
    color: white;
    font-weight: 800;
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
  }

  .win-announcement {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: #FF1744;
    border: 10px solid #00BCD4;
    padding: 60px 50px;
    text-align: center;
    z-index: 10000;
    max-width: 500px;
    box-shadow: 0 0 100px rgba(0, 0, 0, 0.8);
  }

  .win-announcement.show {
    animation: winShow 0.4s forwards;
  }

  @keyframes winShow {
    0% { transform: translate(-50%, -50%) scale(0); }
    100% { transform: translate(-50%, -50%) scale(1); }
  }

  .win-symbol {
    font-size: 5em;
    margin-bottom: 20px;
  }

  .win-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    color: white;
    margin-bottom: 15px;
    letter-spacing: 4px;
    text-shadow: 3px 3px 0 #000;
  }

  .win-prize {
    font-size: 1.4em;
    font-weight: 800;
    line-height: 1.4;
    margin-bottom: 25px;
    color: white;
  }

  .win-close {
    background: #00BCD4;
    color: white;
    border: none;
    padding: 15px 40px;
    font-size: 1.3em;
    font-weight: 800;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 2px;
    font-family: 'Bebas Neue', sans-serif;
  }

  .win-close:hover {
    background: #00ACC1;
  }

  .game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #FF1744;
    border: 10px solid #00BCD4;
    padding: 50px;
    text-align: center;
    z-index: 100;
    display: none;
  }

  .game-over h2 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    color: white;
    margin-bottom: 20px;
    letter-spacing: 4px;
  }

  .game-over p {
    font-size: 1.3em;
    font-weight: 700;
    margin-bottom: 10px;
  }

  .error-screen {
    text-align: center;
    padding: 60px;
    background: #FF1744;
    border: 10px solid #00BCD4;
    max-width: 600px;
  }

  .error-icon {
    font-size: 5em;
    margin-bottom: 20px;
  }

  .error-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    color: white;
    margin-bottom: 20px;
    letter-spacing: 4px;
  }

  .error-message {
    font-size: 1.3em;
    line-height: 1.6;
  }
</style>
</head>
<body>
<div class="side-panel">
  <div class="header">
    <h1 class="title">U.S. LAWSHIELD</h1>
    <p class="subtitle">PLINKO GAME</p>
  </div>

  <div class="puck-holder">
    <div class="puck-holder-title">GRAB PUCK</div>
    <canvas id="puckHolderCanvas" width="120" height="120" class="puck-holder-canvas"></canvas>
  </div>

  <div class="info-badge">
    <div>BOARD: <span id="currentBoard">A</span></div>
    <div style="margin-top: 8px;">PUCKS: <span id="puckCounter">0</span></div>
  </div>

  <div class="legend-panel">
    <div class="legend-title">PRIZES</div>
    <div id="legendContent"></div>
  </div>
</div>

<div class="game-container" id="gameContainer">
  <div class="canvas-wrapper">
    <canvas id="plinkoCanvas"></canvas>
    <div class="game-over" id="gameOverScreen">
      <h2>GAME COMPLETE!</h2>
      <p>All pucks have been played.</p>
      <p>Thank you for participating!</p>
    </div>
  </div>
</div>

<div class="win-announcement" id="winAnnouncement">
  <div class="win-symbol" id="winSymbol"></div>
  <div class="win-title">YOU WON!</div>
  <div class="win-prize" id="winPrize"></div>
  <button class="win-close" onclick="closeWinAnnouncement()">CONTINUE</button>
</div>

<script>
// ==================== PRIZE CONFIGURATION ====================
const PRIZE_CONFIG = {
  A: {
    name: "Board A",
    prizes: [
      { symbol: 'üéÅ', name: '$25 Gift Card', color: '#FF4081' },
      { symbol: '‚è∞', name: '1 Hour Campaign of Your Choice', color: '#00BCD4' },
      { symbol: 'üë•', name: 'Shadow an Agent for 1 Hour', color: '#FF4081' },
      { symbol: 'üö™', name: 'Leave 15min Early / Come in 15min Late', color: '#00BCD4' },
      { symbol: '‚òï', name: 'Extra 15 Minute Break', color: '#FFFFFF' },
      { symbol: 'üìä', name: 'Replace QA Score with Call of Your Choice', color: '#00BCD4' },
      { symbol: 'üíº', name: 'Coffee with Leadership', color: '#FF4081' },
      { symbol: '‚è∞', name: '1 Hour Campaign of Your Choice', color: '#00BCD4' },
      { symbol: 'üéÅ', name: '$25 Gift Card', color: '#FF4081' }
    ]
  },
  B: {
    name: "Board B",
    prizes: [
      { symbol: 'üïë', name: '2 Hours Campaign of Your Choice', color: '#9C27B0' },
      { symbol: 'üí∞', name: '$50 Gift Card', color: '#FF5722' },
      { symbol: '‚è±Ô∏è', name: 'Leave 30 Minutes Early', color: '#2196F3' },
      { symbol: 'üíØ', name: 'Replace Lowest QA Score with 100', color: '#4CAF50' },
      { symbol: 'üïì', name: '4 Hours Campaign of Your Choice', color: '#FFC107' },
      { symbol: 'üçΩÔ∏è', name: 'Lunch on Leadership', color: '#FF9800' },
      { symbol: 'üé¥', name: 'Wild Card', color: '#00BCD4' },
      { symbol: 'üí∞', name: '$50 Gift Card', color: '#FF5722' },
      { symbol: 'üïë', name: '2 Hours Campaign of Your Choice', color: '#9C27B0' }
    ]
  }
};

// ==================== CONFIGURATION ====================
const JSONBIN_CONFIG = {
  BASE_URL: 'https://api.jsonbin.io/v3/b',
  HEADERS: {
    'Content-Type': 'application/json',
    'X-Master-Key': '$2a$10$RKQHusd9D3WIzERQBzwFC.KOpKHvEzT8.MIGGqceg5GyTT.YfIpk6',
    'X-Access-Key': '$2a$10$sUTX2utrrPnHXKLkvPRrvea57/mv64FybLk3ythIqvzGB9TcGQgS6'
  }
};

// ==================== AUDIO SYSTEM ====================
class AudioSystem {
  constructor() {
    this.audioContext = null;
    this.initialized = false;
  }

  init() {
    if (this.initialized) return;
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.initialized = true;
    } catch (e) {
      console.log('Audio not available');
    }
  }

  playPegHit(intensity = 0.5) {
    if (!this.initialized) return;
    
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    const baseFreq = 400 + (intensity * 600);
    osc.frequency.setValueAtTime(baseFreq, now);
    osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.3, now + 0.08);
    
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.1 * intensity, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    osc.start(now);
    osc.stop(now + 0.08);
  }

  playWin() {
    if (!this.initialized) return;
    
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    
    for (let i = 0; i < 5; i++) {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      const freq = 300 + (i * 100);
      osc.frequency.setValueAtTime(freq, now + i * 0.1);
      
      gain.gain.setValueAtTime(0, now + i * 0.1);
      gain.gain.linearRampToValueAtTime(0.15, now + i * 0.1 + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.2);
      
      osc.connect(gain);
      gain.connect(ctx.destination);
      
      osc.start(now + i * 0.1);
      osc.stop(now + i * 0.1 + 0.2);
    }
  }
}

const audioSystem = new AudioSystem();

// ==================== GAME INITIALIZATION ====================
const urlParams = new URLSearchParams(window.location.search);
const binId = urlParams.get('game');

if (!binId) {
  showError();
} else {
  initGame(binId);
}

function showError() {
  document.body.innerHTML = `
    <div class="error-screen">
      <div class="error-icon">‚ö†Ô∏è</div>
      <h2 class="error-title">INVALID SESSION</h2>
      <p class="error-message">
        This game link is invalid or has expired.<br>
        Please contact the administrator for a new game link.
      </p>
    </div>
  `;
}

async function initGame(binId) {
  try {
    const gameState = await readGameBin(binId);
    
    if (!gameState) {
      throw new Error('Failed to load game');
    }
    
    gameState.playerConnected = true;
    gameState.lastUpdated = new Date().toISOString();
    await updateGameBin(binId, gameState);
    
    startPlinko(binId, gameState);
    
  } catch (error) {
    console.error('Error loading game:', error);
    showError();
  }
}

async function updateGameBin(binId, data) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}`, {
      method: 'PUT',
      headers: JSONBIN_CONFIG.HEADERS,
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error updating JSONBin:', error);
    throw error;
  }
}

async function readGameBin(binId) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_CONFIG.HEADERS['X-Master-Key'],
        'X-Access-Key': JSONBIN_CONFIG.HEADERS['X-Access-Key']
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data.record;
  } catch (error) {
    console.error('Error reading from JSONBin:', error);
    return null;
  }
}

function closeWinAnnouncement() {
  document.getElementById('winAnnouncement').classList.remove('show');
}

// ==================== MAIN PLINKO GAME ====================
function startPlinko(binId, gameState) {
  const canvas = document.getElementById('plinkoCanvas');
  const ctx = canvas.getContext('2d');
  
  const holderCanvas = document.getElementById('puckHolderCanvas');
  const holderCtx = holderCanvas.getContext('2d');
  
  // Populate legend
  updateLegend(gameState.currentBoard);
  
  // Resize canvas
  const resizeCanvas = () => {
    const container = canvas.parentElement;
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    if (gameActive) {
      initPegs();
      drawBoard();
    }
  };
  
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  
  const W = canvas.width;
  const H = canvas.height;
  
  // ==================== GAME CONSTANTS ====================
  const PUCK_RADIUS = 32;
  const PEG_RADIUS = 7;
  const NUM_ROWS = 12;
  
  const getCurrentPrizes = () => PRIZE_CONFIG[gameState.currentBoard].prizes;
  
  // ==================== GAME STATE ====================
  let pegs = [];
  let currentPuck = null;
  let isDragging = false;
  let animationId = null;
  let particles = [];
  let lastTime = 0;
  let gameActive = true;
  
  // ==================== PEG INITIALIZATION ====================
  function initPegs() {
    pegs = [];
    const startY = H * 0.15;
    const endY = H * 0.75;
    const rowHeight = (endY - startY) / NUM_ROWS;
    
    for (let row = 0; row < NUM_ROWS; row++) {
      const numPegs = 9 + (row % 2);
      const pegSpacing = W / (numPegs + 1);
      const offset = row % 2 === 0 ? pegSpacing / 2 : 0;
      
      for (let col = 0; col < numPegs; col++) {
        pegs.push({
          x: offset + (col + 1) * pegSpacing,
          y: startY + row * rowHeight,
          lastHit: 0
        });
      }
    }
  }

  function updateLegend(board) {
    const prizes = PRIZE_CONFIG[board].prizes;
    const legendContent = document.getElementById('legendContent');
    
    legendContent.innerHTML = prizes.map((prize, index) => `
      <div class="prize-item" style="border-left-color: ${prize.color}">
        <div class="prize-symbol">${prize.symbol}</div>
        <div class="prize-name">${prize.name}</div>
      </div>
    `).join('');
  }

  // ==================== DRAWING FUNCTIONS ====================
  function drawBoard() {
    // Cream/beige background
    ctx.fillStyle = '#F5E6D3';
    ctx.fillRect(0, 0, W, H);
    
    // Draw triangular pattern background
    drawTrianglePattern();
    
    // Draw pegs
    pegs.forEach(peg => {
      // Peg shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.arc(peg.x + 1, peg.y + 1, PEG_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      // Peg body
      ctx.fillStyle = '#D4A76A';
      ctx.beginPath();
      ctx.arc(peg.x, peg.y, PEG_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      // Peg highlight
      ctx.fillStyle = '#E8C9A0';
      ctx.beginPath();
      ctx.arc(peg.x - 2, peg.y - 2, PEG_RADIUS * 0.4, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Draw prize slots
    drawPrizeSlots();
    
    // Draw particles
    drawParticles();
    
    // Draw active puck
    if (currentPuck) {
      drawPuck(currentPuck.x, currentPuck.y);
    }
  }

  function drawTrianglePattern() {
    ctx.strokeStyle = 'rgba(180, 150, 120, 0.3)';
    ctx.lineWidth = 1;
    
    const triangleSize = 30;
    const rows = Math.ceil(H / (triangleSize * 0.866)) + 1;
    const cols = Math.ceil(W / triangleSize) + 1;
    
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const x = col * triangleSize + (row % 2 === 0 ? 0 : triangleSize / 2);
        const y = row * triangleSize * 0.866;
        
        // Draw triangle
        ctx.beginPath();
        if ((row + col) % 2 === 0) {
          ctx.moveTo(x, y);
          ctx.lineTo(x + triangleSize, y);
          ctx.lineTo(x + triangleSize / 2, y + triangleSize * 0.866);
        } else {
          ctx.moveTo(x, y + triangleSize * 0.866);
          ctx.lineTo(x + triangleSize, y + triangleSize * 0.866);
          ctx.lineTo(x + triangleSize / 2, y);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }
  }

  function drawPrizeSlots() {
    const prizes = getCurrentPrizes();
    const slotCount = prizes.length;
    const slotHeight = H * 0.18;
    const bottomY = H - slotHeight;
    const slotWidth = W / slotCount;
    const centerX = W / 2;
    
    prizes.forEach((prize, index) => {
      const slotCenterX = (index + 0.5) * slotWidth;
      const distanceFromCenter = slotCenterX - centerX;
      
      // Perspective slant
      const angleMultiplier = Math.abs(distanceFromCenter) / centerX;
      const slantOffset = angleMultiplier * slotWidth * 0.4;
      
      const leftX = index * slotWidth;
      const rightX = (index + 1) * slotWidth;
      
      const topLeftOffset = distanceFromCenter < 0 ? slantOffset : 0;
      const topRightOffset = distanceFromCenter > 0 ? -slantOffset : 0;
      
      // Draw slot
      ctx.fillStyle = prize.color;
      ctx.beginPath();
      ctx.moveTo(leftX + topLeftOffset, bottomY);
      ctx.lineTo(rightX + topRightOffset, bottomY);
      ctx.lineTo(rightX, H);
      ctx.lineTo(leftX, H);
      ctx.closePath();
      ctx.fill();
      
      // White border
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // Symbol
      ctx.fillStyle = '#FFFFFF';
      ctx.font = `bold 48px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(prize.symbol, slotCenterX, bottomY + slotHeight * 0.5);
    });
  }

  function drawPuck(x, y) {
    // Shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.arc(x + 3, y + 3, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    // Body
    ctx.fillStyle = '#FF3333';
    ctx.beginPath();
    ctx.arc(x, y, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    // Border
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineWidth = 4;
    ctx.stroke();
    
    // Highlight
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.beginPath();
    ctx.arc(x - 8, y - 8, PUCK_RADIUS * 0.3, 0, Math.PI * 2);
    ctx.fill();
    
    // Text
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 16px Montserrat';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('USL', x, y);
  }

  function drawPuckInHolder() {
    holderCtx.clearRect(0, 0, 120, 120);
    
    if (gameState.pucksRemaining > 0 && !currentPuck) {
      const centerX = 60;
      const centerY = 60;
      
      // Shadow
      holderCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      holderCtx.beginPath();
      holderCtx.arc(centerX + 2, centerY + 2, 30, 0, Math.PI * 2);
      holderCtx.fill();
      
      // Body
      holderCtx.fillStyle = '#FF3333';
      holderCtx.beginPath();
      holderCtx.arc(centerX, centerY, 30, 0, Math.PI * 2);
      holderCtx.fill();
      
      // Border
      holderCtx.strokeStyle = '#FFFFFF';
      holderCtx.lineWidth = 3;
      holderCtx.stroke();
      
      // Highlight
      holderCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      holderCtx.beginPath();
      holderCtx.arc(centerX - 6, centerY - 6, 8, 0, Math.PI * 2);
      holderCtx.fill();
      
      // Text
      holderCtx.fillStyle = '#FFFFFF';
      holderCtx.font = 'bold 14px Montserrat';
      holderCtx.textAlign = 'center';
      holderCtx.textBaseline = 'middle';
      holderCtx.fillText('USL', centerX, centerY);
    }
  }

  function drawParticles() {
    particles = particles.filter(p => {
      p.life--;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.2;
      
      if (p.life <= 0) return false;
      
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      
      return true;
    });
    
    ctx.globalAlpha = 1;
  }

  // ==================== PHYSICS ====================
  function updatePhysics(timestamp) {
    if (!currentPuck || !gameActive) return;
    
    const deltaTime = Math.min(16, timestamp - lastTime) / 16;
    lastTime = timestamp;
    
    // Gravity
    currentPuck.vy += 0.5 * deltaTime;
    currentPuck.x += currentPuck.vx * deltaTime;
    currentPuck.y += currentPuck.vy * deltaTime;
    
    // Air resistance
    currentPuck.vx *= 0.998;
    currentPuck.vy *= 0.999;
    
    // Wall collisions
    const wallMargin = PUCK_RADIUS + 5;
    if (currentPuck.x < wallMargin) {
      currentPuck.x = wallMargin;
      currentPuck.vx = Math.abs(currentPuck.vx) * 0.6;
    } else if (currentPuck.x > W - wallMargin) {
      currentPuck.x = W - wallMargin;
      currentPuck.vx = -Math.abs(currentPuck.vx) * 0.6;
    }
    
    // Peg collisions
    const currentTime = Date.now();
    
    pegs.forEach(peg => {
      if (currentTime - peg.lastHit < 100) return;
      
      const dx = currentPuck.x - peg.x;
      const dy = currentPuck.y - peg.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDistance = PUCK_RADIUS + PEG_RADIUS + 2;
      
      if (distance < minDistance) {
        peg.lastHit = currentTime;
        
        // Sound
        const speed = Math.sqrt(currentPuck.vx ** 2 + currentPuck.vy ** 2);
        const intensity = Math.min(1, speed / 10);
        audioSystem.playPegHit(intensity);
        
        // Collision response
        const nx = dx / distance;
        const ny = dy / distance;
        
        const overlap = minDistance - distance;
        currentPuck.x += nx * overlap;
        currentPuck.y += ny * overlap;
        
        const dotProduct = currentPuck.vx * nx + currentPuck.vy * ny;
        currentPuck.vx -= 1.6 * dotProduct * nx;
        currentPuck.vy -= 1.6 * dotProduct * ny;
        
        // Add slight randomness
        currentPuck.vx += (Math.random() - 0.5) * 0.8;
        currentPuck.vy += (Math.random() - 0.5) * 0.4;
        
        // Particles
        for (let i = 0; i < 4; i++) {
          particles.push({
            x: currentPuck.x,
            y: currentPuck.y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 20,
            maxLife: 20,
            size: 2,
            color: '#00BCD4'
          });
        }
      }
    });
    
    // Check if reached bottom
    if (currentPuck.y + PUCK_RADIUS > H - H * 0.18) {
      handlePuckLanding();
      return;
    }
    
    drawBoard();
    animationId = requestAnimationFrame(updatePhysics);
  }

  async function handlePuckLanding() {
    const prizes = getCurrentPrizes();
    const slotWidth = W / prizes.length;
    const slotIndex = Math.min(prizes.length - 1, Math.max(0, Math.floor(currentPuck.x / slotWidth)));
    const prize = prizes[slotIndex];
    
    // Play win sound
    audioSystem.playWin();
    
    // Show win announcement
    document.getElementById('winSymbol').textContent = prize.symbol;
    document.getElementById('winPrize').textContent = prize.name;
    document.getElementById('winAnnouncement').classList.add('show');
    
    // Celebration particles
    for (let i = 0; i < 80; i++) {
      const angle = (Math.PI * 2 * i) / 80;
      const speed = Math.random() * 8 + 4;
      
      particles.push({
        x: currentPuck.x,
        y: H - H * 0.09,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 4,
        life: 50,
        maxLife: 50,
        size: 3,
        color: prize.color
      });
    }
    
    // Record result
    if (!gameState.results) gameState.results = [];
    gameState.results.push({
      board: gameState.currentBoard,
      slot: slotIndex,
      prize: {
        symbol: prize.symbol,
        name: prize.name
      },
      timestamp: new Date().toISOString()
    });
    
    gameState.pucksRemaining--;
    gameState.lastUpdated = new Date().toISOString();
    
    await saveState();
    
    // Board switch
    if (gameState.boardConfig === 'BOTH' && gameState.currentBoard === 'A' && 
        gameState.pucksRemaining <= gameState.puckCountB) {
      gameState.currentBoard = 'B';
      updateLegend('B');
      initPegs();
    }
    
    // Game completion
    if (gameState.pucksRemaining <= 0) {
      gameActive = false;
      setTimeout(() => {
        document.getElementById('gameOverScreen').style.display = 'block';
      }, 2000);
    }
    
    currentPuck = null;
    updateDisplay();
    drawPuckInHolder();
    
    cancelAnimationFrame(animationId);
    drawBoard();
  }

  function updateDisplay() {
    document.getElementById('puckCounter').textContent = gameState.pucksRemaining;
    document.getElementById('currentBoard').textContent = gameState.currentBoard;
  }

  async function saveState() {
    try {
      await updateGameBin(binId, gameState);
    } catch (error) {
      console.error('Failed to save game state:', error);
    }
  }

  // ==================== EVENT HANDLERS ====================
  function getCanvasCoords(e, targetCanvas) {
    const rect = targetCanvas.getBoundingClientRect();
    const scaleX = targetCanvas.width / rect.width;
    const scaleY = targetCanvas.height / rect.height;
    
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  }

  function handleHolderMouseDown(e) {
    if (!gameActive || currentPuck || gameState.pucksRemaining === 0) return;
    
    audioSystem.init();
    
    const coords = getCanvasCoords(e, holderCanvas);
    const distance = Math.sqrt((coords.x - 60) ** 2 + (coords.y - 60) ** 2);
    
    if (distance < 35) {
      isDragging = true;
      
      // Convert holder coords to canvas coords
      const canvasRect = canvas.getBoundingClientRect();
      const holderRect = holderCanvas.getBoundingClientRect();
      
      currentPuck = {
        x: W / 2,
        y: 50,
        vx: 0,
        vy: 0
      };
      
      drawPuckInHolder();
      drawBoard();
    }
  }

  function handleCanvasMove(e) {
    if (!isDragging || !currentPuck) return;
    
    const coords = getCanvasCoords(e, canvas);
    currentPuck.x = Math.max(PUCK_RADIUS, Math.min(W - PUCK_RADIUS, coords.x));
    currentPuck.y = Math.max(PUCK_RADIUS, Math.min(H - PUCK_RADIUS, coords.y));
    drawBoard();
  }

  function handleRelease(e) {
    if (!isDragging || !currentPuck) return;
    
    isDragging = false;
    
    // Check if at top of board and not over pegs
    const topThreshold = H * 0.15;
    
    if (currentPuck.y > topThreshold) {
      // Too low - reset
      currentPuck = null;
      drawPuckInHolder();
      drawBoard();
      return;
    }
    
    // Drop straight down from current position
    currentPuck.vx = 0;
    currentPuck.vy = 0.5;
    
    lastTime = performance.now();
    animationId = requestAnimationFrame(updatePhysics);
    saveState();
  }

  // Holder events
  holderCanvas.addEventListener('mousedown', handleHolderMouseDown);
  holderCanvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    handleHolderMouseDown(e);
  });

  // Canvas events
  canvas.addEventListener('mousemove', handleCanvasMove);
  canvas.addEventListener('mouseup', handleRelease);
  canvas.addEventListener('mouseleave', handleRelease);
  
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    handleCanvasMove(e);
  });
  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    handleRelease(e);
  });

  // ==================== INITIALIZE ====================
  initPegs();
  updateDisplay();
  drawBoard();
  drawPuckInHolder();
}
</script>
</body>
</html>
