<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>U.S. LawShield PLINKO</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  :root {
    --plinko-red: #FF0000;
    --plinko-blue: #0047AB;
    --plinko-yellow: #FFD700;
    --plinko-green: #228B22;
    --plinko-dark-blue: #002244;
    --plinko-gold: #FFD700;
  }
  
  body {
    font-family: 'Montserrat', sans-serif;
    background: linear-gradient(135deg, #001933 0%, #003366 100%);
    min-height: 100vh;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    overflow: hidden;
  }

  .game-container {
    max-width: 800px;
    width: 100%;
  }

  .header {
    text-align: center;
    padding: 20px;
    margin-bottom: 20px;
  }

  .title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3.5em;
    letter-spacing: 6px;
    text-shadow: 0 0 30px var(--plinko-gold), 3px 3px 0 #000;
    color: white;
    margin-bottom: 5px;
  }

  .subtitle {
    font-size: 1.2em;
    letter-spacing: 3px;
    color: var(--plinko-gold);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    font-weight: 800;
  }

  .canvas-wrapper {
    position: relative;
    border-radius: 20px;
    overflow: hidden;
    box-shadow: 0 0 60px rgba(255, 215, 0, 0.6);
    border: 6px solid var(--plinko-gold);
    background: linear-gradient(160deg, #000428 0%, #004e92 100%);
  }

  #plinkoCanvas {
    display: block;
    width: 100%;
    background: linear-gradient(160deg, #000428 0%, #004e92 100%);
    cursor: pointer;
  }

  .game-info {
    position: absolute;
    top: 20px;
    left: 20px;
    right: 20px;
    display: flex;
    justify-content: space-between;
    z-index: 10;
    pointer-events: none;
  }

  .info-badge {
    background: linear-gradient(135deg, #8B0000 0%, #FF0000 100%);
    padding: 10px 20px;
    border-radius: 20px;
    border: 3px solid var(--plinko-gold);
    color: white;
    font-weight: 800;
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
  }

  .drop-zone {
    position: absolute;
    top: 120px;
    left: 50%;
    transform: translateX(-50%);
    width: 150px;
    height: 60px;
    background: linear-gradient(135deg, #FF0000 0%, #8B0000 100%);
    border: 4px solid var(--plinko-gold);
    border-radius: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 800;
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 2px;
    box-shadow: 0 8px 25px rgba(255, 0, 0, 0.6);
    z-index: 5;
  }

  .instruction {
    text-align: center;
    color: var(--plinko-gold);
    font-weight: 700;
    font-size: 16px;
    margin-top: 15px;
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  .error-screen {
    text-align: center;
    padding: 40px;
    background: linear-gradient(135deg, rgba(0, 34, 68, 0.9) 0%, rgba(36, 89, 152, 0.9) 100%);
    border-radius: 25px;
    border: 4px solid var(--plinko-gold);
    box-shadow: 0 15px 50px rgba(0,0,0,0.6);
  }

  .error-icon {
    font-size: 4em;
    margin-bottom: 20px;
  }

  .error-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 2.5em;
    color: var(--plinko-gold);
    margin-bottom: 15px;
    letter-spacing: 3px;
  }

  .error-message {
    font-size: 1.2em;
    color: white;
    line-height: 1.6;
  }

  .release-warning {
    position: absolute;
    top: 200px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(139, 0, 0, 0.95);
    padding: 15px 25px;
    border-radius: 15px;
    border: 3px solid var(--plinko-gold);
    color: white;
    font-weight: 700;
    font-size: 16px;
    text-align: center;
    z-index: 100;
    box-shadow: 0 10px 30px rgba(0,0,0,0.8);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }

  .release-warning.show {
    opacity: 1;
  }

  .bigwin {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-size: 6em;
    color: var(--plinko-gold);
    text-shadow: 0 0 50px var(--plinko-gold), 0 0 100px #FF0000;
    z-index: 9999;
    pointer-events: none;
    animation: win 2s forwards;
    font-family: 'Bebas Neue', sans-serif;
    letter-spacing: 6px;
  }

  @keyframes win {
    0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }

  .game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #8B0000 0%, #FF0000 100%);
    padding: 30px;
    border-radius: 20px;
    border: 4px solid var(--plinko-gold);
    color: white;
    text-align: center;
    z-index: 100;
    box-shadow: 0 15px 40px rgba(0,0,0,0.8);
    display: none;
  }

  .game-over h2 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    margin-bottom: 15px;
    letter-spacing: 3px;
    color: var(--plinko-gold);
  }
</style>
</head>
<body>
<div class="game-container" id="gameContainer">
  <div class="header">
    <h1 class="title">U.S. LAWSHIELD PLINKO</h1>
    <p class="subtitle">LEGAL DEFENSE FOR SELF DEFENSE®</p>
  </div>

  <div class="canvas-wrapper">
    <div class="game-info">
      <div class="info-badge" id="currentBoard">BOARD A</div>
      <div class="info-badge">PUCKS: <span id="puckCounter">0</span></div>
    </div>
    <div class="drop-zone">DROP ZONE</div>
    <canvas id="plinkoCanvas" width="800" height="1000"></canvas>
    <div class="release-warning" id="releaseWarning">
      ⚠️ MOVE TO DROP ZONE TO RELEASE!
    </div>
    <div class="game-over" id="gameOverScreen" style="display: none;">
      <h2>GAME COMPLETE!</h2>
      <p>All pucks have been used.</p>
      <p>Thank you for playing!</p>
    </div>
  </div>

  <div class="instruction">DRAG PUCK TO DROP ZONE → RELEASE TO PLAY!</div>
</div>

<script>
const JSONBIN_CONFIG = {
  BASE_URL: 'https://api.jsonbin.io/v3/b',
  HEADERS: {
    'Content-Type': 'application/json',
    'X-Master-Key': '$2a$10$NckuWO.y9g8.amyZZWkc8.lKIMS.AVSCyN1qT9/0d5EtRjuV9lmS2',
    'X-Access-Key': '$2a$10$g6RfQ66H6XQyYy3D848Cfurvs0dXgVt92aV0Rr0UqchZrBZwr7Vpy'
  }
};

// Check for game parameter
const urlParams = new URLSearchParams(window.location.search);
const binId = urlParams.get('game');

if (!binId) {
  showError();
} else {
  initGame(binId);
}

function showError() {
  document.getElementById('gameContainer').innerHTML = `
    <div class="error-screen">
      <div class="error-icon">⚠️</div>
      <h2 class="error-title">INVALID SESSION</h2>
      <p class="error-message">
        This game link is invalid or has expired.<br>
        Please contact the administrator for a new game link.
      </p>
    </div>
  `;
}

async function initGame(binId) {
  try {
    const gameState = await readGameBin(binId);
    
    if (!gameState) {
      throw new Error('Failed to load game');
    }
    
    // Mark player as connected
    gameState.playerConnected = true;
    gameState.lastUpdated = new Date().toISOString();
    await updateGameBin(binId, gameState);
    
    // Start game
    startPlinko(binId, gameState);
    
  } catch (error) {
    console.error('Error loading game:', error);
    showError();
  }
}

async function updateGameBin(binId, data) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}`, {
      method: 'PUT',
      headers: JSONBIN_CONFIG.HEADERS,
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error updating JSONBin:', error);
    throw error;
  }
}

async function readGameBin(binId) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_CONFIG.HEADERS['X-Master-Key'],
        'X-Access-Key': JSONBIN_CONFIG.HEADERS['X-Access-Key']
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data.record;
  } catch (error) {
    console.error('Error reading from JSONBin:', error);
    return null;
  }
}

function startPlinko(binId, gameState) {
  const canvas = document.getElementById('plinkoCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  
  // Correct drop zone position at TOP of board
  const DROP_ZONE_Y = 120;
  const DROP_ZONE_HEIGHT = 60;
  const DROP_ZONE_WIDTH = 150;
  const DROP_ZONE_CENTER = W / 2;
  
  const PUCK_RADIUS = 18;
  const PEG_RADIUS = 6;
  const NUM_ROWS = 12; // Classic Plinko rows
  const NUM_SLOTS = 9;

  let pegs = [];
  let currentPuck = null;
  let isDragging = false;
  let hoverPuck = { x: DROP_ZONE_CENTER, y: DROP_ZONE_Y + DROP_ZONE_HEIGHT/2 };
  let animationId = null;
  let particles = [];
  let lastTime = 0;
  let gameActive = true;

  // Authentic Price is Right slot values
  const SLOT_VALUES = {
    A: [100, 500, 1000, 0, 10000, 0, 1000, 500, 100],
    B: [0, 300, 600, 1000, 5000, 1000, 600, 300, 0]
  };

  // Initialize triangular peg layout (authentic Plinko)
  function initPegs() {
    pegs = [];
    const startY = DROP_ZONE_Y + DROP_ZONE_HEIGHT + 60; // Start pegs below drop zone
    const rowHeight = (H - startY - 200) / NUM_ROWS;
    
    for (let row = 0; row < NUM_ROWS; row++) {
      const numPegs = 8 + (row % 2); // Alternating pattern for authentic look
      const offset = row % 2 === 0 ? (W / 8) / 2 : 0;
      const horizontalSpacing = W / 8;
      
      for (let col = 0; col < numPegs; col++) {
        pegs.push({
          x: offset + col * horizontalSpacing,
          y: startY + row * rowHeight,
          lastHit: 0
        });
      }
    }
  }

  function drawBoard() {
    // Clear with dark blue gradient background
    const bgGradient = ctx.createLinearGradient(0, 0, 0, H);
    bgGradient.addColorStop(0, '#000428');
    bgGradient.addColorStop(1, '#004e92');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, W, H);
    
    // Draw board border
    ctx.strokeStyle = '#FFD700';
    ctx.lineWidth = 8;
    ctx.strokeRect(20, 20, W - 40, H - 40);
    
    // Draw decorative header
    const headerGradient = ctx.createLinearGradient(0, 0, 0, 80);
    headerGradient.addColorStop(0, '#8B0000');
    headerGradient.addColorStop(1, '#FF0000');
    ctx.fillStyle = headerGradient;
    ctx.fillRect(40, 40, W - 80, 80);
    
    ctx.strokeStyle = '#FFD700';
    ctx.lineWidth = 4;
    ctx.strokeRect(40, 40, W - 80, 80);
    
    // Draw title in header
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 32px "Bebas Neue"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('PLINKO', W/2, 80);
    
    // Draw pegs with authentic appearance
    ctx.shadowColor = '#FFD700';
    ctx.shadowBlur = 8;
    
    pegs.forEach(peg => {
      const pegGradient = ctx.createRadialGradient(
        peg.x - 2, peg.y - 2, 0, peg.x, peg.y, PEG_RADIUS
      );
      pegGradient.addColorStop(0, '#FFFFFF');
      pegGradient.addColorStop(0.3, '#FFD700');
      pegGradient.addColorStop(1, '#FF8C00');
      
      ctx.fillStyle = pegGradient;
      ctx.beginPath();
      ctx.arc(peg.x, peg.y, PEG_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner highlight
      ctx.fillStyle = '#FFFFFF';
      ctx.beginPath();
      ctx.arc(peg.x - 2, peg.y - 2, PEG_RADIUS * 0.3, 0, Math.PI * 2);
      ctx.fill();
    });
    
    ctx.shadowBlur = 0;
    
    // Draw slots at BOTTOM (correct placement)
    const slotHeight = 100;
    const slotWidth = W / NUM_SLOTS;
    const slotY = H - slotHeight;
    
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;
    
    currentSlotValues.forEach((value, index) => {
      // Slot background with gradient
      const slotGradient = ctx.createLinearGradient(
        index * slotWidth, slotY, index * slotWidth, H
      );
      
      if (value === 10000 || value === 5000) {
        // Jackpot slot - gold gradient
        slotGradient.addColorStop(0, '#FFD700');
        slotGradient.addColorStop(1, '#FF8C00');
      } else if (value === 0) {
        // Zero slot - gray
        slotGradient.addColorStop(0, '#666666');
        slotGradient.addColorStop(1, '#333333');
      } else {
        // Money slots - red gradient
        slotGradient.addColorStop(0, '#FF0000');
        slotGradient.addColorStop(1, '#8B0000');
      }
      
      ctx.fillStyle = slotGradient;
      ctx.fillRect(index * slotWidth, slotY, slotWidth, slotHeight);
      
      // Slot border
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = value === 10000 || value === 5000 ? 6 : 3;
      ctx.strokeRect(index * slotWidth, slotY, slotWidth, slotHeight);
      
      // Slot value
      ctx.fillStyle = '#FFFFFF';
      ctx.font = value === 10000 || value === 5000 ? 'bold 26px "Bebas Neue"' : 'bold 22px "Bebas Neue"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (value === 10000 || value === 5000) {
        ctx.shadowColor = '#FF0000';
        ctx.shadowBlur = 12;
      }
      
      const displayValue = value === 0 ? '0' : `$${value.toLocaleString()}`;
      ctx.fillText(displayValue, index * slotWidth + slotWidth/2, slotY + slotHeight/2);
      
      ctx.shadowBlur = 0;
    });
    
    // Draw hover puck
    if (gameState.pucksRemaining > 0 && !currentPuck && !isDragging) {
      drawPuck(hoverPuck.x, hoverPuck.y, true);
    }
    
    // Draw current puck
    if (currentPuck) {
      drawPuck(currentPuck.x, currentPuck.y, false);
    }
    
    // Draw particles
    particles.forEach((particle, index) => {
      particle.life--;
      if (particle.life <= 0) {
        particles.splice(index, 1);
        return;
      }
      
      particle.x += particle.vx;
      particle.y += particle.vy;
      particle.vy += 0.1; // Gentle gravity
      
      ctx.globalAlpha = particle.life / particle.maxLife;
      ctx.fillStyle = particle.color;
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
  }

  function drawPuck(x, y, isHover = false) {
    ctx.save();
    
    // Puck shadow
    ctx.shadowColor = isHover ? '#FF0000' : '#8B0000';
    ctx.shadowBlur = isHover ? 20 : 12;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    // Puck body with realistic gradient
    const puckGradient = ctx.createRadialGradient(
      x - 5, y - 5, 0, x, y, PUCK_RADIUS
    );
    
    if (isHover) {
      puckGradient.addColorStop(0, '#FFFFFF');
      puckGradient.addColorStop(0.3, '#FF6B6B');
      puckGradient.addColorStop(0.7, '#FF0000');
      puckGradient.addColorStop(1, '#8B0000');
    } else {
      puckGradient.addColorStop(0, '#FFFFFF');
      puckGradient.addColorStop(0.4, '#FF0000');
      puckGradient.addColorStop(1, '#8B0000');
    }
    
    ctx.fillStyle = puckGradient;
    ctx.beginPath();
    ctx.arc(x, y, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    // Puck border
    ctx.strokeStyle = '#FFD700';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Puck highlight
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.beginPath();
    ctx.arc(x - 4, y - 4, PUCK_RADIUS * 0.3, 0, Math.PI * 2);
    ctx.fill();
    
    // USL text
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 12px Montserrat';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('USL', x, y);
    
    ctx.restore();
  }

  function updatePhysics(timestamp) {
    if (!currentPuck || !gameActive) return;
    
    const deltaTime = Math.min(16, timestamp - lastTime) / 16;
    lastTime = timestamp;
    
    // Realistic physics with proper energy conservation
    currentPuck.vy += 0.4 * deltaTime; // Gravity
    currentPuck.x += currentPuck.vx * deltaTime;
    currentPuck.y += currentPuck.vy * deltaTime;
    
    // Air resistance (very slight)
    currentPuck.vx *= 0.999;
    currentPuck.vy *= 0.999;
    
    // Wall collisions with realistic bounce
    if (currentPuck.x - PUCK_RADIUS < 40) {
      currentPuck.x = 40 + PUCK_RADIUS;
      currentPuck.vx = Math.abs(currentPuck.vx) * 0.8; // Energy loss on wall hit
    } else if (currentPuck.x + PUCK_RADIUS > W - 40) {
      currentPuck.x = W - 40 - PUCK_RADIUS;
      currentPuck.vx = -Math.abs(currentPuck.vx) * 0.8;
    }
    
    // Realistic peg collisions
    const currentTime = Date.now();
    
    pegs.forEach(peg => {
      if (currentTime - peg.lastHit < 50) return; // Collision cooldown
      
      const dx = currentPuck.x - peg.x;
      const dy = currentPuck.y - peg.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDistance = PUCK_RADIUS + PEG_RADIUS;
      
      if (distance < minDistance) {
        peg.lastHit = currentTime;
        
        // Normalize collision vector
        const nx = dx / distance;
        const ny = dy / distance;
        
        // Separate puck from peg
        const overlap = minDistance - distance;
        currentPuck.x += nx * overlap * 0.7;
        currentPuck.y += ny * overlap * 0.7;
        
        // Calculate reflection (realistic bounce)
        const dotProduct = currentPuck.vx * nx + currentPuck.vy * ny;
        currentPuck.vx -= 1.8 * dotProduct * nx;
        currentPuck.vy -= 1.8 * dotProduct * ny;
        
        // Add slight randomness for authentic Plinko behavior
        currentPuck.vx += (Math.random() - 0.5) * 0.8;
        currentPuck.vy += (Math.random() - 0.5) * 0.4;
        
        // Create collision effect
        for (let i = 0; i < 3; i++) {
          particles.push({
            x: currentPuck.x,
            y: currentPuck.y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 15,
            maxLife: 15,
            size: Math.random() * 2 + 1,
            color: '#FFD700'
          });
        }
      }
    });
    
    // Check if puck reached slots at BOTTOM
    if (currentPuck.y + PUCK_RADIUS > H - 100) {
      handlePuckLanding();
      return;
    }
    
    // Continue animation
    drawBoard();
    animationId = requestAnimationFrame(updatePhysics);
  }

  function handlePuckLanding() {
    const slotWidth = W / NUM_SLOTS;
    const slotIndex = Math.min(NUM_SLOTS - 1, Math.max(0, Math.floor(currentPuck.x / slotWidth)));
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;
    const slotValue = currentSlotValues[slotIndex];
    
    // Record result
    if (!gameState.results) gameState.results = [];
    gameState.results.push({
      board: gameState.currentBoard,
      slot: slotIndex,
      value: slotValue,
      timestamp: Date.now()
    });
    
    // Celebration particles based on value
    const particleCount = slotValue >= 1000 ? 80 : 40;
    const particleColor = slotValue >= 5000 ? '#FFD700' : slotValue >= 1000 ? '#FF0000' : '#666666';
    
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: currentPuck.x,
        y: H - 50,
        vx: (Math.random() - 0.5) * 10,
        vy: -Math.random() * 12,
        life: 50,
        maxLife: 50,
        size: Math.random() * 3 + 2,
        color: particleColor
      });
    }
    
    // Big celebration for jackpot
    if (slotValue === 10000 || slotValue === 5000) {
      const winElement = document.createElement('div');
      winElement.className = 'bigwin';
      winElement.textContent = slotValue === 10000 ? 'JACKPOT!' : 'BIG WIN!';
      document.body.appendChild(winElement);
      setTimeout(() => winElement.remove(), 2500);
    }
    
    // Update game state
    gameState.pucksRemaining--;
    gameState.lastUpdated = new Date().toISOString();
    
    // Save state
    saveState();
    
    // Check for board switch (if using both boards)
    if (gameState.boardConfig === 'BOTH' && gameState.currentBoard === 'A' && 
        gameState.pucksRemaining <= gameState.puckCountB) {
      gameState.currentBoard = 'B';
      document.getElementById('currentBoard').textContent = 'BOARD B';
      initPegs();
    }
    
    // Check for game completion
    if (gameState.pucksRemaining <= 0) {
      gameActive = false;
      setTimeout(() => {
        document.getElementById('gameOverScreen').style.display = 'block';
      }, 2000);
    }
    
    currentPuck = null;
    updateDisplay();
    
    cancelAnimationFrame(animationId);
    drawBoard();
  }

  function animateHoverPuck() {
    if (!gameActive) return;
    
    if (currentPuck || gameState.pucksRemaining === 0) {
      requestAnimationFrame(animateHoverPuck);
      return;
    }
    
    // Gentle hovering motion within drop zone area
    const time = Date.now() * 0.001;
    hoverPuck.x = DROP_ZONE_CENTER + Math.sin(time) * (DROP_ZONE_WIDTH/2 - PUCK_RADIUS - 10);
    
    drawBoard();
    requestAnimationFrame(animateHoverPuck);
  }

  function updateDisplay() {
    document.getElementById('puckCounter').textContent = gameState.pucksRemaining;
    document.getElementById('currentBoard').textContent = `BOARD ${gameState.currentBoard}`;
    
    // Visual feedback for low puck count
    const puckCounter = document.getElementById('puckCounter');
    if (gameState.pucksRemaining <= 2) {
      puckCounter.style.color = '#FF6B6B';
    } else if (gameState.pucksRemaining <= 5) {
      puckCounter.style.color = '#FFA726';
    } else {
      puckCounter.style.color = '#FFFFFF';
    }
  }

  async function saveState() {
    try {
      await updateGameBin(binId, gameState);
    } catch (error) {
      console.error('Failed to save game state:', error);
    }
  }

  // Check if position is within drop zone
  function isInDropZone(x, y) {
    return x >= DROP_ZONE_CENTER - DROP_ZONE_WIDTH/2 && 
           x <= DROP_ZONE_CENTER + DROP_ZONE_WIDTH/2 &&
           y >= DROP_ZONE_Y && 
           y <= DROP_ZONE_Y + DROP_ZONE_HEIGHT;
  }

  // Event handlers
  canvas.addEventListener('mousemove', (e) => {
    if (!gameActive) return;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    if (isDragging && currentPuck) {
      // Allow dragging anywhere, but only release in drop zone
      currentPuck.x = Math.max(PUCK_RADIUS + 40, Math.min(W - PUCK_RADIUS - 40, x));
      currentPuck.y = Math.max(PUCK_RADIUS + 40, Math.min(H - PUCK_RADIUS - 100, y));
      drawBoard();
    } else if (gameState.pucksRemaining > 0 && !currentPuck) {
      // Hover puck stays in drop zone
      hoverPuck.x = Math.max(DROP_ZONE_CENTER - DROP_ZONE_WIDTH/2 + PUCK_RADIUS, 
                           Math.min(DROP_ZONE_CENTER + DROP_ZONE_WIDTH/2 - PUCK_RADIUS, x));
      hoverPuck.y = DROP_ZONE_Y + DROP_ZONE_HEIGHT/2;
    }
  });

  canvas.addEventListener('mousedown', (e) => {
    if (!gameActive || currentPuck || gameState.pucksRemaining === 0) return;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    // Check if clicking near hover puck in drop zone
    const distance = Math.sqrt(Math.pow(x - hoverPuck.x, 2) + Math.pow(y - hoverPuck.y, 2));
    
    if (distance < PUCK_RADIUS * 1.5 && isInDropZone(x, y)) {
      isDragging = true;
      currentPuck = { 
        x: x, 
        y: y, 
        vx: 0, 
        vy: 0
      };
      gameState.lastUpdated = new Date().toISOString();
      saveState();
      drawBoard();
    }
  });

  canvas.addEventListener('mouseup', () => {
    if (!gameActive || !isDragging || !currentPuck) return;
    
    isDragging = false;
    
    // CORRECT: Must be in drop zone to release
    if (!isInDropZone(currentPuck.x, currentPuck.y)) {
      const warning = document.getElementById('releaseWarning');
      warning.classList.add('show');
      setTimeout(() => warning.classList.remove('show'), 2000);
      currentPuck = null;
      drawBoard();
      return;
    }
    
    // Realistic initial velocity - slight randomness for authentic Plinko
    const centerX = DROP_ZONE_CENTER;
    currentPuck.vx = (currentPuck.x - centerX) * 0.5; // Horizontal velocity based on drop position
    currentPuck.vy = 2 + Math.random() * 0.5; // Consistent downward velocity
    
    lastTime = performance.now();
    animationId = requestAnimationFrame(updatePhysics);
    saveState();
  });

  // Initialize game
  initPegs();
  updateDisplay();
  drawBoard();
  animateHoverPuck();
}
</script>
</body>
</html>
