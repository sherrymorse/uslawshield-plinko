<!DOCTYPE html>
<html lang="UTF-8">
<head>
<meta charset="UTF-8">
<title>U.S. LawShield PLINKO – Neon Revival Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  :root {
    --neon-blue: #00aaff;
    --neon-green: #39ff14;
    --deep-navy: #001533;
    --plinko-gold: #FFD700;
    --highlight-blue: #00e1ff;
    --shadow-deep: rgba(0,0,0,0.8);
  }
  
  body {
    font-family: 'Montserrat', sans-serif;
    background: radial-gradient(circle at 50% 15%, #002244 0%, #000814 100%);
    min-height: 100vh;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    overflow: hidden;
  }

  .game-container {
    width: 90vw;
    height: 95vh;
    max-width: 1000px;
    max-height: 1000px;
    position: relative;
    border-radius: 28px;
    border: 10px solid var(--plinko-gold);
    box-shadow: 0 0 80px rgba(0,255,150,0.6), inset 0 0 25px rgba(0,255,255,0.25);
    background: radial-gradient(circle at 20% 0%, #00ffcc 0%, #002b5c 35%, #000814 100%);
    overflow: hidden;
  }

  .header {
    position: absolute;
    top: 0;
    width: 100%;
    height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(180deg, var(--highlight-blue) 0%, #0072ce 70%, #001533 100%);
    border-bottom: 5px solid var(--plinko-gold);
    box-shadow: 0 0 40px var(--highlight-blue);
    z-index: 10;
  }

  .title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3.4rem;
    letter-spacing: 8px;
    text-shadow: 0 0 25px var(--plinko-gold), 0 0 40px var(--neon-green), 2px 2px 0 #000;
    color: #ffffff;
  }

  .subtitle {
    position: absolute;
    top: 105px;
    width: 100%;
    text-align: center;
    font-size: 0.9rem;
    letter-spacing: 3px;
    color: var(--plinko-gold);
    text-shadow: 0 0 10px #000;
    z-index: 10;
  }

  .canvas-wrapper {
    position: absolute;
    top: 120px;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 12px 18px 18px;
  }

  #plinkoCanvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: pointer;
    border-radius: 22px;
    box-shadow: inset 0 0 35px rgba(0,0,0,0.9), 0 0 40px rgba(0,255,200,0.4);
    background: radial-gradient(circle at 50% 0%, #004e92 0%, #001533 40%, #000814 100%);
  }

  .game-info {
    position: absolute;
    top: 130px;
    left: 24px;
    right: 24px;
    display: flex;
    justify-content: space-between;
    z-index: 12;
    pointer-events: none;
  }

  .info-badge {
    background: linear-gradient(135deg, #0072ce 0%, #00ffcc 100%);
    padding: 8px 18px;
    border-radius: 18px;
    border: 3px solid var(--plinko-gold);
    color: white;
    font-weight: 800;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 5px 18px rgba(0,0,0,0.6);
  }

  .drop-zone {
    position: absolute;
    top: 160px;
    left: 50%;
    transform: translateX(-50%);
    width: 180px;
    height: 56px;
    background: linear-gradient(135deg, var(--neon-blue) 0%, var(--neon-green) 100%);
    border: 4px solid var(--plinko-gold);
    border-radius: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 800;
    font-size: 15px;
    text-transform: uppercase;
    letter-spacing: 3px;
    box-shadow: 0 0 35px var(--highlight-blue);
    z-index: 12;
  }

  .instruction {
    position: absolute;
    bottom: 8px;
    left: 0; right: 0;
    text-align: center;
    color: var(--plinko-gold);
    font-weight: 700;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 3px;
    text-shadow: 0 0 10px #000;
    z-index: 10;
  }

  .release-warning {
    position: absolute;
    top: 220px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    padding: 10px 18px;
    border-radius: 14px;
    border: 3px solid var(--plinko-gold);
    color: white;
    font-weight: 700;
    font-size: 13px;
    text-align: center;
    z-index: 100;
    box-shadow: 0 10px 25px rgba(0,0,0,0.9);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.25s ease-out;
  }

  .release-warning.show {
    opacity: 1;
  }

  .error-screen {
    text-align: center;
    padding: 40px;
    background: linear-gradient(135deg, rgba(0, 34, 68, 0.9) 0%, rgba(36, 89, 152, 0.9) 100%);
    border-radius: 25px;
    border: 4px solid var(--plinko-gold);
    box-shadow: 0 15px 50px rgba(0,0,0,0.6);
  }

  .error-icon {
    font-size: 4em;
    margin-bottom: 20px;
  }

  .error-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 2.5em;
    color: var(--plinko-gold);
    margin-bottom: 15px;
    letter-spacing: 3px;
  }

  .error-message {
    font-size: 1.2em;
    color: white;
    line-height: 1.6;
  }

  .bigwin {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-size: 5.5em;
    color: var(--plinko-gold);
    text-shadow: 0 0 50px var(--plinko-gold), 0 0 100px #FF0000;
    z-index: 9999;
    pointer-events: none;
    animation: win 2s forwards;
    font-family: 'Bebas Neue', sans-serif;
    letter-spacing: 6px;
  }

  @keyframes win {
    0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.25) rotate(8deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }

  .game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #00ff99 0%, #0072ce 90%);
    padding: 30px 40px;
    border-radius: 20px;
    border: 4px solid var(--plinko-gold);
    color: white;
    text-align: center;
    z-index: 100;
    box-shadow: 0 15px 40px rgba(0,0,0,0.8);
    display: none;
  }

  .game-over h2 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    margin-bottom: 15px;
    letter-spacing: 3px;
    color: var(--plinko-gold);
    text-shadow: 0 0 20px #fff;
  }

  .slot-values {
    position: absolute;
    bottom: 40px;
    left: 0;
    width: 100%;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3em;
    color: #fff;
    text-align: center;
    letter-spacing: 3px;
    display: flex;
    justify-content: space-evenly;
    text-shadow: 0 0 10px #000;
    pointer-events: none;
    z-index: 15;
  }

  .slot-values span.jackpot {
    color: var(--plinko-gold);
    text-shadow: 0 0 15px var(--plinko-gold), 0 0 25px var(--neon-green);
    font-size: 1.5em;
  }

</style>
</head>
<body>
<div class="game-container" id="gameContainer">
  <div class="header">
    <h1 class="title">U.S. LAWSHIELD PLINKO</h1>
  </div>
  <p class="subtitle">LEGAL DEFENSE FOR SELF DEFENSE®</p>

  <div class="canvas-wrapper">
    <div class="game-info">
      <div class="info-badge" id="currentBoard">BOARD A</div>
      <div class="info-badge">PUCKS: <span id="puckCounter">0</span></div>
    </div>
    <div class="drop-zone">DROP ZONE</div>
    <canvas id="plinkoCanvas" width="800" height="1000"></canvas>
    <div class="release-warning" id="releaseWarning">⚠️ MOVE TO DROP ZONE TO RELEASE!</div>
    <div class="game-over" id="gameOverScreen">
      <h2>GAME COMPLETE!</h2>
      <p>All pucks have been used.</p>
      <p>Thank you for playing!</p>
    </div>
    <div class="slot-values" id="slotVals"></div>
    <div class="instruction">DRAG PUCK INTO DROP ZONE → RELEASE TO PLAY!</div>
  </div>
</div>

<script>
// JSONBin config
const JSONBIN_CONFIG = {
  BASE_URL: 'https://api.jsonbin.io/v3/b',
  HEADERS: {
    'Content-Type': 'application/json',
    'X-Master-Key': '$2a$10$NckuWO.y9g8.amyZZWkc8.lKIMS.AVSCyN1qT9/0d5EtRjuV9lmS2',
    'X-Access-Key': '$2a$10$g6RfQ66H6XQyYy3D848Cfurvs0dXgVt92aV0Rr0UqchZrBZwr7Vpy'
  }
};

const urlParams = new URLSearchParams(window.location.search);
const binId = urlParams.get('game');

if (!binId) {
  showError();
} else {
  initGame(binId);
}

function showError() {
  document.getElementById('gameContainer').innerHTML = `
    <div class="error-screen">
      <div class="error-icon">⚠️</div>
      <h2 class="error-title">INVALID SESSION</h2>
      <p class="error-message">
        This game link is invalid or has expired.<br>
        Please contact the administrator for a new game link.
      </p>
    </div>
  `;
}

async function updateGameBin(binId, data) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}`, {
      method: 'PUT',
      headers: JSONBIN_CONFIG.HEADERS,
      body: JSON.stringify(data)
    });
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    return await response.json();
  } catch (error) {
    console.error('Error updating JSONBin:', error);
    throw error;
  }
}

async function readGameBin(binId) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_CONFIG.HEADERS['X-Master-Key'],
        'X-Access-Key': JSONBIN_CONFIG.HEADERS['X-Access-Key']
      }
    });
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.record;
  } catch (error) {
    console.error('Error reading from JSONBin:', error);
    return null;
  }
}

async function initGame(binId) {
  try {
    const gameState = await readGameBin(binId);
    if (!gameState) throw new Error('Failed to load game');
    gameState.playerConnected = true;
    gameState.lastUpdated = new Date().toISOString();
    await updateGameBin(binId, gameState);
    startPlinko(binId, gameState);
  } catch (error) {
    console.error('Error loading game:', error);
    showError();
  }
}

// ---- PLINKO CORE ----
function startPlinko(binId, gameState) {
  const canvas = document.getElementById('plinkoCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // Layout constants: tuned for “TV board” look
  const DROP_ZONE_Y = 160; // align with CSS
  const DROP_ZONE_HEIGHT = 56;
  const DROP_ZONE_WIDTH = 180;
  const DROP_ZONE_CENTER = W / 2;

  const PUCK_RADIUS = 18;
  const PEG_RADIUS = 6;
  const NUM_ROWS = 12;
  const NUM_SLOTS = 9;

  let pegs = [];
  let currentPuck = null;
  let isDragging = false;
  let hoverPuck = { x: DROP_ZONE_CENTER, y: DROP_ZONE_Y + DROP_ZONE_HEIGHT / 2 };
  let animationId = null;
  let particles = [];
  let lastTime = 0;
  let gameActive = true;

  // Authentic slot tables
  const SLOT_VALUES = {
    A: [100, 500, 1000, 0, 10000, 0, 1000, 500, 100],
    B: [0, 300, 600, 1000, 5000, 1000, 600, 300, 0]
  };

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playPegSound() {
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.value = 600 + Math.random() * 200;
      gain.gain.value = 0.05;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.06);
    } catch (e) {
      // ignore if context not ready
    }
  }

  // Initialize pegs in a triangular grid
  function initPegs() {
    pegs = [];
    const startY = DROP_ZONE_Y + DROP_ZONE_HEIGHT + 60;
    const rowHeight = (H - startY - 180) / NUM_ROWS;

    for (let row = 0; row < NUM_ROWS; row++) {
      const numPegs = NUM_SLOTS + (row % 2 === 0 ? 0 : -1);
      const offset = row % 2 === 0 ? 0.5 : 0.0;
      const spacing = (W - 120) / NUM_SLOTS;
      const rowY = startY + row * rowHeight;
      for (let i = 0; i < numPegs; i++) {
        const x = 60 + (i + offset) * spacing;
        pegs.push({ x, y: rowY, lastHit: 0 });
      }
    }
  }

  // Draw angled slots (vanishing point feel)
  function drawSlots() {
    const slotHeight = 110;
    const slotY = H - slotHeight;
    const slotWidth = W / NUM_SLOTS;
    const vanishingCenter = W / 2;
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;

    ctx.save();
    for (let index = 0; index < NUM_SLOTS; index++) {
      const x0 = index * slotWidth;
      const x1 = x0 + slotWidth;
      const slotCenter = (x0 + x1) / 2;
      const offset = (slotCenter - vanishingCenter) / (W / 2); // -1..1
      const skew = offset * 0.18; // tilt scaling

      const value = currentSlotValues[index];
      const gradient = ctx.createLinearGradient(x0, slotY, x1, slotY + slotHeight);
      if (value === 10000 || value === 5000) {
        gradient.addColorStop(0, "#ffd700");
        gradient.addColorStop(1, "#ff8c00");
      } else if (value === 0) {
        gradient.addColorStop(0, "#555");
        gradient.addColorStop(1, "#222");
      } else {
        gradient.addColorStop(0, "#ff004c");
        gradient.addColorStop(1, "#8b0000");
      }

      ctx.save();
      ctx.transform(1, 0, skew, 1, 0, 0);
      ctx.fillStyle = gradient;
      ctx.fillRect(x0, slotY, slotWidth, slotHeight);
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = value === 10000 || value === 5000 ? 5 : 3;
      ctx.strokeRect(x0, slotY, slotWidth, slotHeight);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawBoard() {
    // Background
    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, "#001933");
    bgGrad.addColorStop(0.35, "#003d7a");
    bgGrad.addColorStop(1, "#000814");
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    // Side panels
    const leftPanelGrad = ctx.createLinearGradient(0, 0, 0, H);
    leftPanelGrad.addColorStop(0, "#00ffcc");
    leftPanelGrad.addColorStop(1, "#0072ce");
    ctx.fillStyle = leftPanelGrad;
    ctx.fillRect(0, 0, 30, H);

    const rightPanelGrad = ctx.createLinearGradient(0, 0, 0, H);
    rightPanelGrad.addColorStop(0, "#0072ce");
    rightPanelGrad.addColorStop(1, "#00ff99");
    ctx.fillStyle = rightPanelGrad;
    ctx.fillRect(W - 30, 0, 30, H);

    // Inner frame
    ctx.strokeStyle = "#FFD700";
    ctx.lineWidth = 6;
    ctx.strokeRect(35, 20, W - 70, H - 60);

    // Pegs
    ctx.shadowColor = "#FFD700";
    ctx.shadowBlur = 8;
    pegs.forEach(peg => {
      const pegGrad = ctx.createRadialGradient(peg.x - 2, peg.y - 2, 0, peg.x, peg.y, PEG_RADIUS);
      pegGrad.addColorStop(0, "#ffffff");
      pegGrad.addColorStop(0.4, "#ffe066");
      pegGrad.addColorStop(1, "#ff8c00");
      ctx.fillStyle = pegGrad;
      ctx.beginPath();
      ctx.arc(peg.x, peg.y, PEG_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.beginPath();
      ctx.arc(peg.x - 2, peg.y - 2, PEG_RADIUS * 0.3, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.shadowBlur = 0;

    // Slots
    drawSlots();

    // Puck
    if (currentPuck) {
      drawPuck(currentPuck.x, currentPuck.y, false);
    } else if (gameState.pucksRemaining > 0 && !isDragging) {
      drawPuck(hoverPuck.x, hoverPuck.y, true);
    }

    // Particles
    particles.forEach((p, idx) => {
      p.life--;
      if (p.life <= 0) return;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.12;
      ctx.globalAlpha = p.life / p.maxLife;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });
    particles = particles.filter(p => p.life > 0);
  }

  function drawPuck(x, y, isHover) {
    ctx.save();
    ctx.shadowColor = isHover ? "#00ffcc" : "#ff004c";
    ctx.shadowBlur = isHover ? 18 : 12;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    const grad = ctx.createRadialGradient(x - 6, y - 6, 0, x, y, PUCK_RADIUS);
    if (isHover) {
      grad.addColorStop(0, "#ffffff");
      grad.addColorStop(0.3, "#00ffcc");
      grad.addColorStop(0.7, "#00aaff");
      grad.addColorStop(1, "#004e92");
    } else {
      grad.addColorStop(0, "#ffffff");
      grad.addColorStop(0.3, "#ff4b81");
      grad.addColorStop(0.8, "#ff004c");
      grad.addColorStop(1, "#8b0000");
    }

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#FFD700";
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.beginPath();
    ctx.arc(x - 5, y - 5, PUCK_RADIUS * 0.3, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#ffffff";
    ctx.font = "bold 12px Montserrat";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("USL", x, y);
    ctx.restore();
  }

  function updatePhysics(timestamp) {
    if (!currentPuck || !gameActive) return;
    const deltaTime = Math.min(20, timestamp - lastTime) / 16;
    lastTime = timestamp;

    // Gravity
    currentPuck.vy += 0.45 * deltaTime;
    currentPuck.x += currentPuck.vx * deltaTime;
    currentPuck.y += currentPuck.vy * deltaTime;

    // Slight air resistance
    currentPuck.vx *= 0.999;
    currentPuck.vy *= 0.999;

    // Walls
    if (currentPuck.x - PUCK_RADIUS < 50) {
      currentPuck.x = 50 + PUCK_RADIUS;
      currentPuck.vx = Math.abs(currentPuck.vx) * 0.85;
    } else if (currentPuck.x + PUCK_RADIUS > W - 50) {
      currentPuck.x = W - 50 - PUCK_RADIUS;
      currentPuck.vx = -Math.abs(currentPuck.vx) * 0.85;
    }

    const now = Date.now();
    pegs.forEach(peg => {
      if (now - peg.lastHit < 40) return;
      const dx = currentPuck.x - peg.x;
      const dy = currentPuck.y - peg.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = PUCK_RADIUS + PEG_RADIUS;
      if (dist < minDist) {
        peg.lastHit = now;
        const nx = dx / (dist || 0.0001);
        const ny = dy / (dist || 0.0001);
        const overlap = (minDist - dist) || 0.5;
        currentPuck.x += nx * overlap * 0.6;
        currentPuck.y += ny * overlap * 0.6;

        const dot = currentPuck.vx * nx + currentPuck.vy * ny;
        currentPuck.vx -= 1.9 * dot * nx;
        currentPuck.vy -= 1.9 * dot * ny;

        currentPuck.vx += (Math.random() - 0.5) * 0.7;
        currentPuck.vy += (Math.random() - 0.5) * 0.5;

        for (let i = 0; i < 4; i++) {
          particles.push({
            x: currentPuck.x,
            y: currentPuck.y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 18,
            maxLife: 18,
            size: Math.random() * 2.2 + 1,
            color: "#FFD700"
          });
        }
        playPegSound();
      }
    });

    if (currentPuck.y + PUCK_RADIUS > H - 110) {
      handlePuckLanding();
      return;
    }

    drawBoard();
    animationId = requestAnimationFrame(updatePhysics);
  }

  function handlePuckLanding() {
    const slotWidth = W / NUM_SLOTS;
    const slotIndex = Math.min(NUM_SLOTS - 1, Math.max(0, Math.floor(currentPuck.x / slotWidth)));
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;
    const slotValue = currentSlotValues[slotIndex];

    if (!gameState.results) gameState.results = [];
    gameState.results.push({
      board: gameState.currentBoard,
      slot: slotIndex,
      value: slotValue,
      timestamp: Date.now()
    });

    const particleCount = slotValue >= 1000 ? 90 : 40;
    const color = slotValue >= 5000 ? "#FFD700" : slotValue >= 1000 ? "#00ffcc" : "#888888";
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: currentPuck.x,
        y: H - 70,
        vx: (Math.random() - 0.5) * 10,
        vy: -Math.random() * 12,
        life: 50,
        maxLife: 50,
        size: Math.random() * 3.5 + 2,
        color
      });
    }

    if (slotValue === 10000 || slotValue === 5000) {
      const winElement = document.createElement('div');
      winElement.className = 'bigwin';
      winElement.textContent = slotValue === 10000 ? 'JACKPOT!' : 'BIG WIN!';
      document.body.appendChild(winElement);
      setTimeout(() => winElement.remove(), 2500);
    }

    gameState.pucksRemaining--;
    gameState.lastUpdated = new Date().toISOString();

    saveState();

    if (gameState.boardConfig === 'BOTH' &&
        gameState.currentBoard === 'A' &&
        gameState.pucksRemaining <= gameState.puckCountB) {
      gameState.currentBoard = 'B';
      document.getElementById('currentBoard').textContent = 'BOARD B';
      initPegs();
      updateSlotText();
    }

    if (gameState.pucksRemaining <= 0) {
      gameActive = false;
      setTimeout(() => {
        document.getElementById('gameOverScreen').style.display = 'block';
      }, 2000);
    }

    currentPuck = null;
    updateDisplay();
    cancelAnimationFrame(animationId);
    drawBoard();
  }

  function animateHoverPuck() {
    if (!gameActive) return;
    if (currentPuck || gameState.pucksRemaining === 0) {
      requestAnimationFrame(animateHoverPuck);
      return;
    }
    const time = Date.now() * 0.002;
    hoverPuck.x = DROP_ZONE_CENTER + Math.sin(time) * (DROP_ZONE_WIDTH / 2 - PUCK_RADIUS - 10);
    hoverPuck.y = DROP_ZONE_Y + DROP_ZONE_HEIGHT / 2;
    drawBoard();
    requestAnimationFrame(animateHoverPuck);
  }

  function updateDisplay() {
    document.getElementById('puckCounter').textContent = gameState.pucksRemaining;
    document.getElementById('currentBoard').textContent = `BOARD ${gameState.currentBoard}`;
    const puckCounterEl = document.getElementById('puckCounter');
    if (gameState.pucksRemaining <= 2) {
      puckCounterEl.style.color = '#ff6b6b';
    } else if (gameState.pucksRemaining <= 5) {
      puckCounterEl.style.color = '#ffb347';
    } else {
      puckCounterEl.style.color = '#ffffff';
    }
  }

  async function saveState() {
    try {
      await updateGameBin(binId, gameState);
    } catch (error) {
      console.error('Failed to save game state:', error);
    }
  }

  function isInDropZone(x, y) {
    return (
      x >= DROP_ZONE_CENTER - DROP_ZONE_WIDTH / 2 &&
      x <= DROP_ZONE_CENTER + DROP_ZONE_WIDTH / 2 &&
      y >= DROP_ZONE_Y &&
      y <= DROP_ZONE_Y + DROP_ZONE_HEIGHT
    );
  }

  canvas.addEventListener('mousemove', (e) => {
    if (!gameActive) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    if (isDragging && currentPuck) {
      currentPuck.x = Math.max(PUCK_RADIUS + 50, Math.min(W - PUCK_RADIUS - 50, x));
      currentPuck.y = Math.max(PUCK_RADIUS + 60, Math.min(H - PUCK_RADIUS - 140, y));
      drawBoard();
    } else if (gameState.pucksRemaining > 0 && !currentPuck) {
      hoverPuck.x = Math.max(
        DROP_ZONE_CENTER - DROP_ZONE_WIDTH / 2 + PUCK_RADIUS,
        Math.min(DROP_ZONE_CENTER + DROP_ZONE_WIDTH / 2 - PUCK_RADIUS, x)
      );
      hoverPuck.y = DROP_ZONE_Y + DROP_ZONE_HEIGHT / 2;
    }
  });

  canvas.addEventListener('mousedown', (e) => {
    if (!gameActive || currentPuck || gameState.pucksRemaining === 0) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    const distance = Math.sqrt(Math.pow(x - hoverPuck.x, 2) + Math.pow(y - hoverPuck.y, 2));
    if (distance < PUCK_RADIUS * 1.7 && isInDropZone(x, y)) {
      isDragging = true;
      currentPuck = { x, y, vx: 0, vy: 0 };
      gameState.lastUpdated = new Date().toISOString();
      saveState();
      drawBoard();
    }
  });

  canvas.addEventListener('mouseup', () => {
    if (!gameActive || !isDragging || !currentPuck) return;
    isDragging = false;
    if (!isInDropZone(currentPuck.x, currentPuck.y)) {
      const warning = document.getElementById('releaseWarning');
      warning.classList.add('show');
      setTimeout(() => warning.classList.remove('show'), 2000);
      currentPuck = null;
      drawBoard();
      return;
    }

    // FIX: ensure the puck starts falling straight down from where it is
    currentPuck.vx = 0;  // <-- no sideways launch
    currentPuck.vy = 2.5; // small consistent downward nudge

    lastTime = performance.now();
    animationId = requestAnimationFrame(updatePhysics);
    saveState();
  });

  function updateSlotText() {
    const slotValsEl = document.getElementById('slotVals');
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;
    slotValsEl.innerHTML = currentSlotValues.map(v => {
      if (v === 0) return `<span>0</span>`;
      if (v === 10000 || v === 5000) return `<span class="jackpot">$${v.toLocaleString()}</span>`;
      return `<span>$${v}</span>`;
    }).join('');
  }

  initPegs();
  updateDisplay();
  updateSlotText();
  drawBoard();
  animateHoverPuck();
}
</script>
</body>
</html>
