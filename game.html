<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>U.S. LawShield PLINKO - Ultimate Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@400;600;800;900&display=swap" rel="stylesheet">
<style>
  * { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
  }
  
  :root {
    --seahawks-navy: #002244;
    --seahawks-blue: #0047AB;
    --seahawks-green: #69BE28;
    --seahawks-silver: #A5ACAF;
    --neon-green: #39FF14;
    --bright-blue: #00D9FF;
    --gold: #FFD700;
    --hot-pink: #FF1493;
  }
  
  body {
    font-family: 'Montserrat', sans-serif;
    background: radial-gradient(circle at 50% 50%, #001a33 0%, #000811 100%);
    min-height: 100vh;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 10px;
    overflow: hidden;
    position: relative;
  }

  /* Animated background effects */
  body::before {
    content: '';
    position: fixed;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(105, 190, 40, 0.1) 0%, transparent 50%);
    animation: pulse 4s ease-in-out infinite;
    pointer-events: none;
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 0.3; }
    50% { transform: scale(1.1); opacity: 0.5; }
  }

  .game-container {
    width: 95vw;
    max-width: 1400px;
    height: 95vh;
    display: flex;
    flex-direction: column;
    position: relative;
    z-index: 1;
  }

  .header {
    text-align: center;
    padding: 15px 20px;
    margin-bottom: 10px;
    background: linear-gradient(135deg, var(--seahawks-navy) 0%, #003366 100%);
    border-radius: 25px;
    border: 4px solid var(--seahawks-green);
    box-shadow: 
      0 0 40px rgba(105, 190, 40, 0.6),
      inset 0 0 30px rgba(0, 217, 255, 0.2);
    position: relative;
    overflow: hidden;
  }

  .header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(105, 190, 40, 0.3), transparent);
    animation: shine 3s infinite;
  }

  @keyframes shine {
    0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
    100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
  }

  .title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(2.5em, 5vw, 4em);
    letter-spacing: 8px;
    text-shadow: 
      0 0 20px var(--seahawks-green),
      0 0 40px var(--bright-blue),
      4px 4px 0 #000,
      -2px -2px 0 var(--seahawks-green);
    color: white;
    margin-bottom: 5px;
    position: relative;
    z-index: 2;
    animation: titleGlow 2s ease-in-out infinite alternate;
  }

  @keyframes titleGlow {
    0% { text-shadow: 0 0 20px var(--seahawks-green), 0 0 40px var(--bright-blue), 4px 4px 0 #000; }
    100% { text-shadow: 0 0 30px var(--neon-green), 0 0 60px var(--bright-blue), 4px 4px 0 #000; }
  }

  .subtitle {
    font-size: clamp(0.9em, 1.5vw, 1.3em);
    letter-spacing: 4px;
    color: var(--seahawks-green);
    text-shadow: 
      2px 2px 4px rgba(0,0,0,0.8),
      0 0 15px var(--seahawks-green);
    font-weight: 900;
    position: relative;
    z-index: 2;
  }

  .canvas-wrapper {
    position: relative;
    flex: 1;
    border-radius: 30px;
    overflow: visible;
    box-shadow: 
      0 0 80px rgba(105, 190, 40, 0.8),
      0 0 120px rgba(0, 217, 255, 0.4),
      inset 0 0 50px rgba(0, 0, 0, 0.5);
    border: 8px solid var(--seahawks-green);
    background: linear-gradient(180deg, #001428 0%, #002850 50%, #001428 100%);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #plinkoCanvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: grab;
    border-radius: 22px;
  }

  #plinkoCanvas:active {
    cursor: grabbing;
  }

  .game-info {
    position: absolute;
    top: 20px;
    left: 20px;
    right: 20px;
    display: flex;
    justify-content: space-between;
    z-index: 10;
    pointer-events: none;
    gap: 10px;
  }

  .info-badge {
    background: linear-gradient(135deg, var(--seahawks-navy) 0%, #003d7a 100%);
    padding: 12px 25px;
    border-radius: 25px;
    border: 4px solid var(--seahawks-green);
    color: white;
    font-weight: 900;
    font-size: clamp(14px, 1.5vw, 20px);
    text-transform: uppercase;
    letter-spacing: 2px;
    box-shadow: 
      0 8px 20px rgba(0,0,0,0.6),
      0 0 25px rgba(105, 190, 40, 0.6),
      inset 0 0 20px rgba(0, 217, 255, 0.2);
    animation: badgePulse 2s ease-in-out infinite;
  }

  @keyframes badgePulse {
    0%, 100% { box-shadow: 0 8px 20px rgba(0,0,0,0.6), 0 0 25px rgba(105, 190, 40, 0.6); }
    50% { box-shadow: 0 8px 20px rgba(0,0,0,0.6), 0 0 35px rgba(105, 190, 40, 0.9); }
  }

  .instruction {
    text-align: center;
    color: var(--seahawks-green);
    font-weight: 900;
    font-size: clamp(12px, 1.5vw, 18px);
    margin-top: 10px;
    text-transform: uppercase;
    letter-spacing: 3px;
    text-shadow: 
      0 0 10px var(--seahawks-green),
      2px 2px 4px rgba(0,0,0,0.8);
    animation: instructionPulse 1.5s ease-in-out infinite;
  }

  @keyframes instructionPulse {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
  }

  .error-screen {
    text-align: center;
    padding: 60px 40px;
    background: linear-gradient(135deg, rgba(0, 34, 68, 0.95) 0%, rgba(0, 61, 122, 0.95) 100%);
    border-radius: 30px;
    border: 6px solid var(--seahawks-green);
    box-shadow: 
      0 20px 60px rgba(0,0,0,0.8),
      0 0 60px rgba(105, 190, 40, 0.6);
  }

  .error-icon {
    font-size: 5em;
    margin-bottom: 25px;
    animation: errorShake 0.5s ease-in-out infinite;
  }

  @keyframes errorShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
  }

  .error-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    color: var(--seahawks-green);
    margin-bottom: 20px;
    letter-spacing: 4px;
    text-shadow: 0 0 20px var(--seahawks-green);
  }

  .error-message {
    font-size: 1.3em;
    color: white;
    line-height: 1.8;
  }

  .release-warning {
    position: absolute;
    top: 220px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #8B0000 0%, #FF0000 100%);
    padding: 20px 35px;
    border-radius: 20px;
    border: 4px solid var(--gold);
    color: white;
    font-weight: 900;
    font-size: clamp(14px, 1.5vw, 18px);
    text-align: center;
    z-index: 100;
    box-shadow: 
      0 15px 40px rgba(0,0,0,0.9),
      0 0 40px rgba(255, 215, 0, 0.6);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  }

  .release-warning.show {
    opacity: 1;
    animation: warningShake 0.5s ease-in-out;
  }

  @keyframes warningShake {
    0%, 100% { transform: translateX(-50%) rotate(0deg); }
    25% { transform: translateX(-50%) rotate(-5deg); }
    75% { transform: translateX(-50%) rotate(5deg); }
  }

  .bigwin {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-size: clamp(4em, 10vw, 8em);
    color: var(--gold);
    text-shadow: 
      0 0 60px var(--gold),
      0 0 120px var(--seahawks-green),
      0 0 180px var(--bright-blue),
      6px 6px 0 #000;
    z-index: 9999;
    pointer-events: none;
    animation: bigWinAnim 3s forwards;
    font-family: 'Bebas Neue', sans-serif;
    letter-spacing: 10px;
  }

  @keyframes bigWinAnim {
    0% { 
      transform: translate(-50%, -50%) scale(0) rotate(-360deg); 
      opacity: 0; 
    }
    30% { 
      transform: translate(-50%, -50%) scale(1.3) rotate(0deg); 
      opacity: 1; 
    }
    60% { 
      transform: translate(-50%, -50%) scale(0.9); 
    }
    80% { 
      transform: translate(-50%, -50%) scale(1.1); 
    }
    100% { 
      transform: translate(-50%, -50%) scale(1); 
      opacity: 1; 
    }
  }

  .game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, var(--seahawks-navy) 0%, #003d7a 100%);
    padding: 50px;
    border-radius: 30px;
    border: 6px solid var(--seahawks-green);
    color: white;
    text-align: center;
    z-index: 100;
    box-shadow: 
      0 20px 60px rgba(0,0,0,0.9),
      0 0 80px rgba(105, 190, 40, 0.8);
    display: none;
  }

  .game-over h2 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(2.5em, 5vw, 4em);
    margin-bottom: 20px;
    letter-spacing: 5px;
    color: var(--seahawks-green);
    text-shadow: 0 0 30px var(--seahawks-green);
  }

  .game-over p {
    font-size: clamp(1.2em, 2vw, 1.5em);
    margin-bottom: 15px;
    font-weight: 700;
  }

  /* Firework particles for celebrations */
  @keyframes firework {
    0% { 
      transform: translate(0, 0) scale(1);
      opacity: 1;
    }
    100% { 
      transform: translate(var(--tx), var(--ty)) scale(0);
      opacity: 0;
    }
  }
</style>
</head>
<body>
<div class="game-container" id="gameContainer">
  <div class="header">
    <h1 class="title">U.S. LAWSHIELD PLINKO</h1>
    <p class="subtitle">LEGAL DEFENSE FOR SELF DEFENSE¬Æ</p>
  </div>

  <div class="canvas-wrapper">
    <div class="game-info">
      <div class="info-badge" id="currentBoard">BOARD A</div>
      <div class="info-badge">PUCKS: <span id="puckCounter">0</span></div>
    </div>
    <canvas id="plinkoCanvas"></canvas>
    <div class="release-warning" id="releaseWarning">
      ‚ö†Ô∏è RELEASE IN THE DROP RAMP TO PLAY!
    </div>
    <div class="game-over" id="gameOverScreen">
      <h2>GAME COMPLETE!</h2>
      <p>All pucks have been used.</p>
      <p>Thank you for playing!</p>
    </div>
  </div>

  <div class="instruction">üëÜ CLICK THE DROP RAMP ‚Üí DRAG ANYWHERE ‚Üí RELEASE IN RAMP TO DROP! üëÜ</div>
</div>

<script>
// ==================== CONFIGURATION ====================
const JSONBIN_CONFIG = {
  BASE_URL: 'https://api.jsonbin.io/v3/b',
  HEADERS: {
    'Content-Type': 'application/json',
    'X-Master-Key': '$2a$10$NckuWO.y9g8.amyZZWkc8.lKIMS.AVSCyN1qT9/0d5EtRjuV9lmS2',
    'X-Access-Key': '$2a$10$g6RfQ66H6XQyYy3D848Cfurvs0dXgVt92aV0Rr0UqchZrBZwr7Vpy'
  }
};

// ==================== AUDIO SYSTEM ====================
class AudioSystem {
  constructor() {
    this.audioContext = null;
    this.initialized = false;
  }

  init() {
    if (this.initialized) return;
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    this.initialized = true;
  }

  playPegHit(intensity = 0.5) {
    if (!this.initialized) return;
    
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    
    // Oscillator for the "plink" sound
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    // Frequency varies based on intensity (higher = higher pitch)
    const baseFreq = 400 + (intensity * 600);
    osc.frequency.setValueAtTime(baseFreq, now);
    osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.3, now + 0.1);
    
    // Volume envelope
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.15 * intensity, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    osc.start(now);
    osc.stop(now + 0.1);
  }

  playJackpot() {
    if (!this.initialized) return;
    
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    
    // Create a celebratory rising tone sequence
    for (let i = 0; i < 8; i++) {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      const freq = 200 + (i * 150);
      osc.frequency.setValueAtTime(freq, now + i * 0.08);
      
      gain.gain.setValueAtTime(0, now + i * 0.08);
      gain.gain.linearRampToValueAtTime(0.2, now + i * 0.08 + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.15);
      
      osc.connect(gain);
      gain.connect(ctx.destination);
      
      osc.start(now + i * 0.08);
      osc.stop(now + i * 0.08 + 0.15);
    }
  }

  playDrop() {
    if (!this.initialized) return;
    
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.frequency.setValueAtTime(300, now);
    osc.frequency.exponentialRampToValueAtTime(150, now + 0.2);
    
    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    osc.start(now);
    osc.stop(now + 0.2);
  }
}

const audioSystem = new AudioSystem();

// ==================== GAME INITIALIZATION ====================
const urlParams = new URLSearchParams(window.location.search);
const binId = urlParams.get('game');

if (!binId) {
  showError();
} else {
  initGame(binId);
}

function showError() {
  document.getElementById('gameContainer').innerHTML = `
    <div class="error-screen">
      <div class="error-icon">‚ö†Ô∏è</div>
      <h2 class="error-title">INVALID SESSION</h2>
      <p class="error-message">
        This game link is invalid or has expired.<br>
        Please contact the administrator for a new game link.
      </p>
    </div>
  `;
}

async function initGame(binId) {
  try {
    const gameState = await readGameBin(binId);
    
    if (!gameState) {
      throw new Error('Failed to load game');
    }
    
    gameState.playerConnected = true;
    gameState.lastUpdated = new Date().toISOString();
    await updateGameBin(binId, gameState);
    
    startPlinko(binId, gameState);
    
  } catch (error) {
    console.error('Error loading game:', error);
    showError();
  }
}

async function updateGameBin(binId, data) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}`, {
      method: 'PUT',
      headers: JSONBIN_CONFIG.HEADERS,
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error updating JSONBin:', error);
    throw error;
  }
}

async function readGameBin(binId) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_CONFIG.HEADERS['X-Master-Key'],
        'X-Access-Key': JSONBIN_CONFIG.HEADERS['X-Access-Key']
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data.record;
  } catch (error) {
    console.error('Error reading from JSONBin:', error);
    return null;
  }
}

// ==================== MAIN PLINKO GAME ====================
function startPlinko(binId, gameState) {
  const canvas = document.getElementById('plinkoCanvas');
  const ctx = canvas.getContext('2d');
  
  // Make canvas fill the container
  const resizeCanvas = () => {
    const container = canvas.parentElement;
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    if (gameActive) {
      initPegs();
      drawBoard();
    }
  };
  
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  
  const W = canvas.width;
  const H = canvas.height;
  
  // ==================== GAME CONSTANTS ====================
  const PUCK_RADIUS = Math.max(18, W * 0.025);
  const PEG_RADIUS = Math.max(6, W * 0.008);
  const NUM_ROWS = 12;
  const NUM_SLOTS = 9;
  
  // Drop ramp at top (angled downward firing position)
  const DROP_RAMP = {
    x: W * 0.35,
    y: H * 0.08,
    width: W * 0.3,
    height: H * 0.08,
    angle: 0.1 // Slight downward angle
  };
  
  // Slot values for Board A (classic Price is Right pattern)
  const SLOT_VALUES = {
    A: [100, 500, 1000, 0, 10000, 0, 1000, 500, 100],
    B: [0, 300, 600, 1000, 5000, 1000, 600, 300, 0]
  };
  
  // ==================== GAME STATE ====================
  let pegs = [];
  let currentPuck = null;
  let isDragging = false;
  let hoverPuck = { 
    x: DROP_RAMP.x + DROP_RAMP.width / 2, 
    y: DROP_RAMP.y + DROP_RAMP.height / 2 
  };
  let animationId = null;
  let particles = [];
  let lastTime = 0;
  let gameActive = true;
  let glowParticles = [];
  
  // ==================== PEG INITIALIZATION ====================
  function initPegs() {
    pegs = [];
    const startY = DROP_RAMP.y + DROP_RAMP.height + H * 0.08;
    const endY = H - H * 0.18; // Leave room for slanted pockets
    const rowHeight = (endY - startY) / NUM_ROWS;
    
    // Classic Plinko triangular pattern - complete and accurate
    for (let row = 0; row < NUM_ROWS; row++) {
      const numPegs = 9 + (row % 2); // Alternating 9 and 10 pegs
      const pegSpacing = W / (numPegs + 1);
      const offset = row % 2 === 0 ? pegSpacing / 2 : 0;
      
      for (let col = 0; col < numPegs; col++) {
        pegs.push({
          x: offset + (col + 1) * pegSpacing,
          y: startY + row * rowHeight,
          lastHit: 0,
          glowIntensity: 0
        });
      }
    }
  }

  // ==================== DRAWING FUNCTIONS ====================
  function drawBoard() {
    // Dynamic background gradient
    const bgGradient = ctx.createLinearGradient(0, 0, 0, H);
    bgGradient.addColorStop(0, '#001428');
    bgGradient.addColorStop(0.3, '#002850');
    bgGradient.addColorStop(0.7, '#003366');
    bgGradient.addColorStop(1, '#001428');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, W, H);
    
    // Animated grid pattern
    ctx.strokeStyle = 'rgba(105, 190, 40, 0.1)';
    ctx.lineWidth = 1;
    const gridSize = 40;
    const time = Date.now() * 0.0001;
    
    for (let x = 0; x < W; x += gridSize) {
      const wave = Math.sin(x * 0.01 + time) * 10;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + wave, H);
      ctx.stroke();
    }
    
    // Draw drop ramp (angled launching area)
    drawDropRamp();
    
    // Draw pegs with glow effects
    drawPegs();
    
    // Draw slanted pockets at bottom
    drawSlantedPockets();
    
    // Draw glow particles
    drawGlowParticles();
    
    // Draw collision particles
    drawParticles();
    
    // Draw hover puck
    if (gameState.pucksRemaining > 0 && !currentPuck && !isDragging) {
      drawPuck(hoverPuck.x, hoverPuck.y, true);
    }
    
    // Draw active puck
    if (currentPuck) {
      drawPuck(currentPuck.x, currentPuck.y, false);
    }
  }

  function drawDropRamp() {
    const ramp = DROP_RAMP;
    
    // Ramp shadow
    ctx.shadowColor = 'rgba(105, 190, 40, 0.6)';
    ctx.shadowBlur = 30;
    
    // Main ramp body with gradient
    const rampGradient = ctx.createLinearGradient(ramp.x, ramp.y, ramp.x, ramp.y + ramp.height);
    rampGradient.addColorStop(0, '#003d7a');
    rampGradient.addColorStop(0.5, '#002244');
    rampGradient.addColorStop(1, '#001428');
    
    ctx.fillStyle = rampGradient;
    ctx.beginPath();
    ctx.moveTo(ramp.x, ramp.y);
    ctx.lineTo(ramp.x + ramp.width, ramp.y);
    ctx.lineTo(ramp.x + ramp.width - ramp.height * 0.5, ramp.y + ramp.height);
    ctx.lineTo(ramp.x + ramp.height * 0.5, ramp.y + ramp.height);
    ctx.closePath();
    ctx.fill();
    
    // Ramp border with neon glow
    ctx.strokeStyle = '#69BE28';
    ctx.lineWidth = 4;
    ctx.stroke();
    
    // Angled bottom edge (the "ramp" part)
    ctx.strokeStyle = '#00D9FF';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(ramp.x + ramp.height * 0.5, ramp.y + ramp.height);
    ctx.lineTo(ramp.x + ramp.width - ramp.height * 0.5, ramp.y + ramp.height);
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    
    // "DROP ZONE" text
    ctx.fillStyle = '#FFFFFF';
    ctx.font = `bold ${Math.max(16, W * 0.02)}px "Bebas Neue"`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = '#69BE28';
    ctx.shadowBlur = 10;
    ctx.fillText('DROP', ramp.x + ramp.width / 2, ramp.y + ramp.height * 0.35);
    ctx.fillText('ZONE', ramp.x + ramp.width / 2, ramp.y + ramp.height * 0.65);
    ctx.shadowBlur = 0;
  }

  function drawPegs() {
    const currentTime = Date.now();
    
    pegs.forEach(peg => {
      // Decay glow intensity
      if (peg.glowIntensity > 0) {
        peg.glowIntensity -= 0.05;
      }
      
      // Peg glow
      if (peg.glowIntensity > 0) {
        ctx.shadowColor = '#69BE28';
        ctx.shadowBlur = 15 * peg.glowIntensity;
      } else {
        ctx.shadowColor = '#FFD700';
        ctx.shadowBlur = 6;
      }
      
      // Peg gradient
      const pegGradient = ctx.createRadialGradient(
        peg.x - PEG_RADIUS * 0.3, 
        peg.y - PEG_RADIUS * 0.3, 
        0, 
        peg.x, 
        peg.y, 
        PEG_RADIUS
      );
      
      if (peg.glowIntensity > 0) {
        pegGradient.addColorStop(0, '#FFFFFF');
        pegGradient.addColorStop(0.3, '#69BE28');
        pegGradient.addColorStop(0.7, '#00D9FF');
        pegGradient.addColorStop(1, '#003366');
      } else {
        pegGradient.addColorStop(0, '#FFFFFF');
        pegGradient.addColorStop(0.3, '#FFD700');
        pegGradient.addColorStop(0.7, '#FF8C00');
        pegGradient.addColorStop(1, '#8B4513');
      }
      
      ctx.fillStyle = pegGradient;
      ctx.beginPath();
      ctx.arc(peg.x, peg.y, PEG_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      // Highlight
      ctx.fillStyle = peg.glowIntensity > 0 ? 
        'rgba(255, 255, 255, 0.9)' : 
        'rgba(255, 255, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(
        peg.x - PEG_RADIUS * 0.4, 
        peg.y - PEG_RADIUS * 0.4, 
        PEG_RADIUS * 0.3, 
        0, 
        Math.PI * 2
      );
      ctx.fill();
    });
    
    ctx.shadowBlur = 0;
  }

  function drawSlantedPockets() {
    const slotHeight = H * 0.15;
    const bottomY = H - slotHeight;
    const slotWidth = W / NUM_SLOTS;
    const centerX = W / 2;
    const vanishingPoint = { x: centerX, y: bottomY - H * 0.3 }; // Vanishing point above slots
    
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;
    
    currentSlotValues.forEach((value, index) => {
      const slotCenterX = (index + 0.5) * slotWidth;
      const distanceFromCenter = slotCenterX - centerX;
      
      // Calculate perspective angle - center is straight, edges are more angled
      const angleMultiplier = Math.abs(distanceFromCenter) / centerX;
      const slantOffset = angleMultiplier * slotWidth * 0.4;
      
      // Calculate pocket trapezoid points
      const leftX = index * slotWidth;
      const rightX = (index + 1) * slotWidth;
      
      // Top edge slants toward vanishing point
      const topLeftOffset = distanceFromCenter < 0 ? slantOffset : 0;
      const topRightOffset = distanceFromCenter > 0 ? -slantOffset : 0;
      
      // Draw pocket with perspective
      const pocketGradient = ctx.createLinearGradient(
        slotCenterX, 
        bottomY, 
        slotCenterX, 
        H
      );
      
      if (value === 10000) {
        // Jackpot - intense gold
        pocketGradient.addColorStop(0, '#FFD700');
        pocketGradient.addColorStop(0.5, '#FFA500');
        pocketGradient.addColorStop(1, '#FF8C00');
      } else if (value === 5000) {
        // High value - bright green
        pocketGradient.addColorStop(0, '#69BE28');
        pocketGradient.addColorStop(0.5, '#4a8c1f');
        pocketGradient.addColorStop(1, '#2d5a13');
      } else if (value === 0) {
        // Zero - dark gray
        pocketGradient.addColorStop(0, '#555555');
        pocketGradient.addColorStop(1, '#222222');
      } else if (value >= 1000) {
        // High money - bright blue
        pocketGradient.addColorStop(0, '#00D9FF');
        pocketGradient.addColorStop(0.5, '#0099CC');
        pocketGradient.addColorStop(1, '#006699');
      } else {
        // Medium money - teal
        pocketGradient.addColorStop(0, '#20B2AA');
        pocketGradient.addColorStop(0.5, '#187a76');
        pocketGradient.addColorStop(1, '#0f4d4a');
      }
      
      ctx.fillStyle = pocketGradient;
      ctx.beginPath();
      ctx.moveTo(leftX + topLeftOffset, bottomY);
      ctx.lineTo(rightX + topRightOffset, bottomY);
      ctx.lineTo(rightX, H);
      ctx.lineTo(leftX, H);
      ctx.closePath();
      ctx.fill();
      
      // Pocket borders
      ctx.strokeStyle = value === 10000 || value === 5000 ? '#69BE28' : '#FFFFFF';
      ctx.lineWidth = value === 10000 || value === 5000 ? 5 : 3;
      ctx.stroke();
      
      // Add shine effect for high-value pockets
      if (value >= 1000) {
        const shineGradient = ctx.createLinearGradient(
          leftX, 
          bottomY, 
          rightX, 
          bottomY + slotHeight * 0.3
        );
        shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
        shineGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = shineGradient;
        ctx.fill();
      }
      
      // Slot value text
      ctx.shadowColor = value === 10000 || value === 5000 ? '#FFD700' : '#000000';
      ctx.shadowBlur = value === 10000 || value === 5000 ? 20 : 8;
      ctx.fillStyle = '#FFFFFF';
      
      const fontSize = value === 10000 || value === 5000 ? 
        Math.max(24, W * 0.032) : 
        Math.max(18, W * 0.024);
      ctx.font = `bold ${fontSize}px "Bebas Neue"`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      const displayValue = value === 0 ? '0' : `$${value.toLocaleString()}`;
      ctx.fillText(displayValue, slotCenterX, bottomY + slotHeight * 0.4);
      
      // Extra glow for jackpot
      if (value === 10000) {
        ctx.shadowBlur = 30;
        ctx.fillText(displayValue, slotCenterX, bottomY + slotHeight * 0.4);
      }
      
      ctx.shadowBlur = 0;
    });
  }

  function drawPuck(x, y, isHover = false) {
    ctx.save();
    
    // Puck shadow
    ctx.shadowColor = isHover ? '#69BE28' : '#002244';
    ctx.shadowBlur = isHover ? 30 : 20;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    
    // Puck body with vibrant gradient
    const puckGradient = ctx.createRadialGradient(
      x - PUCK_RADIUS * 0.4, 
      y - PUCK_RADIUS * 0.4, 
      0, 
      x, 
      y, 
      PUCK_RADIUS
    );
    
    if (isHover) {
      // Bright animated hover state
      const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
      puckGradient.addColorStop(0, '#FFFFFF');
      puckGradient.addColorStop(0.3, `rgba(105, 190, 40, ${pulse})`);
      puckGradient.addColorStop(0.7, '#00D9FF');
      puckGradient.addColorStop(1, '#002244');
    } else {
      puckGradient.addColorStop(0, '#FFFFFF');
      puckGradient.addColorStop(0.3, '#FF3333');
      puckGradient.addColorStop(0.7, '#CC0000');
      puckGradient.addColorStop(1, '#660000');
    }
    
    ctx.fillStyle = puckGradient;
    ctx.beginPath();
    ctx.arc(x, y, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    // Puck border
    ctx.strokeStyle = isHover ? '#69BE28' : '#FFD700';
    ctx.lineWidth = 4;
    ctx.stroke();
    
    // Highlight
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.beginPath();
    ctx.arc(
      x - PUCK_RADIUS * 0.4, 
      y - PUCK_RADIUS * 0.4, 
      PUCK_RADIUS * 0.35, 
      0, 
      Math.PI * 2
    );
    ctx.fill();
    
    // "USL" text
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#FFFFFF';
    ctx.font = `bold ${Math.max(10, PUCK_RADIUS * 0.6)}px "Montserrat"`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('USL', x, y);
    
    ctx.restore();
  }

  function drawGlowParticles() {
    glowParticles = glowParticles.filter(p => {
      p.life--;
      p.x += p.vx;
      p.y += p.vy;
      p.size *= 0.97;
      
      if (p.life <= 0 || p.size < 0.5) return false;
      
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      
      const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
      gradient.addColorStop(0, p.color);
      gradient.addColorStop(1, 'transparent');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      
      return true;
    });
    
    ctx.globalAlpha = 1;
  }

  function drawParticles() {
    particles = particles.filter(p => {
      p.life--;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.15; // Gravity
      
      if (p.life <= 0) return false;
      
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      
      return true;
    });
    
    ctx.globalAlpha = 1;
  }

  // ==================== PHYSICS ====================
  function updatePhysics(timestamp) {
    if (!currentPuck || !gameActive) return;
    
    const deltaTime = Math.min(16, timestamp - lastTime) / 16;
    lastTime = timestamp;
    
    // Realistic physics
    currentPuck.vy += 0.35 * deltaTime; // Gravity
    currentPuck.x += currentPuck.vx * deltaTime;
    currentPuck.y += currentPuck.vy * deltaTime;
    
    // Air resistance
    currentPuck.vx *= 0.9985;
    currentPuck.vy *= 0.9995;
    
    // Wall collisions
    const wallMargin = PUCK_RADIUS + 5;
    if (currentPuck.x < wallMargin) {
      currentPuck.x = wallMargin;
      currentPuck.vx = Math.abs(currentPuck.vx) * 0.7;
    } else if (currentPuck.x > W - wallMargin) {
      currentPuck.x = W - wallMargin;
      currentPuck.vx = -Math.abs(currentPuck.vx) * 0.7;
    }
    
    // Peg collisions
    const currentTime = Date.now();
    
    pegs.forEach(peg => {
      if (currentTime - peg.lastHit < 100) return;
      
      const dx = currentPuck.x - peg.x;
      const dy = currentPuck.y - peg.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDistance = PUCK_RADIUS + PEG_RADIUS + 2;
      
      if (distance < minDistance) {
        peg.lastHit = currentTime;
        peg.glowIntensity = 1;
        
        // Play peg hit sound
        const intensity = Math.min(1, Math.sqrt(currentPuck.vx ** 2 + currentPuck.vy ** 2) / 10);
        audioSystem.playPegHit(intensity);
        
        // Normalize collision
        const nx = dx / distance;
        const ny = dy / distance;
        
        // Separate puck from peg
        const overlap = minDistance - distance;
        currentPuck.x += nx * overlap;
        currentPuck.y += ny * overlap;
        
        // Reflection with energy conservation
        const dotProduct = currentPuck.vx * nx + currentPuck.vy * ny;
        currentPuck.vx -= 1.6 * dotProduct * nx;
        currentPuck.vy -= 1.6 * dotProduct * ny;
        
        // Add realistic randomness
        currentPuck.vx += (Math.random() - 0.5) * 1.2;
        currentPuck.vy += (Math.random() - 0.5) * 0.6;
        
        // Create impact particles
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: currentPuck.x,
            y: currentPuck.y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 20,
            maxLife: 20,
            size: Math.random() * 2.5 + 1,
            color: '#69BE28'
          });
        }
        
        // Glow trail
        glowParticles.push({
          x: currentPuck.x,
          y: currentPuck.y,
          vx: 0,
          vy: 0,
          life: 15,
          maxLife: 15,
          size: PUCK_RADIUS * 0.8,
          color: '#00D9FF'
        });
      }
    });
    
    // Check if puck reached bottom
    if (currentPuck.y + PUCK_RADIUS > H - H * 0.15) {
      handlePuckLanding();
      return;
    }
    
    drawBoard();
    animationId = requestAnimationFrame(updatePhysics);
  }

  function handlePuckLanding() {
    const slotWidth = W / NUM_SLOTS;
    const slotIndex = Math.min(NUM_SLOTS - 1, Math.max(0, Math.floor(currentPuck.x / slotWidth)));
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;
    const slotValue = currentSlotValues[slotIndex];
    
    // Record result
    if (!gameState.results) gameState.results = [];
    gameState.results.push({
      board: gameState.currentBoard,
      slot: slotIndex,
      value: slotValue,
      timestamp: Date.now()
    });
    
    // Celebration effects
    const particleCount = slotValue >= 5000 ? 150 : slotValue >= 1000 ? 100 : 50;
    const particleColors = slotValue >= 5000 ? 
      ['#FFD700', '#69BE28', '#00D9FF'] : 
      slotValue >= 1000 ? 
      ['#00D9FF', '#69BE28', '#FFFFFF'] : 
      ['#666666', '#999999', '#CCCCCC'];
    
    for (let i = 0; i < particleCount; i++) {
      const angle = (Math.PI * 2 * i) / particleCount;
      const speed = Math.random() * 8 + 4;
      
      particles.push({
        x: currentPuck.x,
        y: H - H * 0.075,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - Math.random() * 6,
        life: 60,
        maxLife: 60,
        size: Math.random() * 4 + 2,
        color: particleColors[Math.floor(Math.random() * particleColors.length)]
      });
    }
    
    // Big win celebration
    if (slotValue === 10000 || slotValue === 5000) {
      audioSystem.playJackpot();
      
      const winElement = document.createElement('div');
      winElement.className = 'bigwin';
      winElement.textContent = slotValue === 10000 ? 'üéâ JACKPOT! üéâ' : 'üí∞ BIG WIN! üí∞';
      document.body.appendChild(winElement);
      setTimeout(() => winElement.remove(), 3000);
      
      // Extra fireworks
      for (let i = 0; i < 200; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 12 + 6;
        
        particles.push({
          x: W / 2,
          y: H / 2,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 80,
          maxLife: 80,
          size: Math.random() * 5 + 2,
          color: ['#FFD700', '#69BE28', '#00D9FF', '#FF1493'][Math.floor(Math.random() * 4)]
        });
      }
    }
    
    // Update game state
    gameState.pucksRemaining--;
    gameState.lastUpdated = new Date().toISOString();
    saveState();
    
    // Board switch logic
    if (gameState.boardConfig === 'BOTH' && gameState.currentBoard === 'A' && 
        gameState.pucksRemaining <= gameState.puckCountB) {
      gameState.currentBoard = 'B';
      document.getElementById('currentBoard').textContent = 'BOARD B';
      initPegs();
    }
    
    // Game completion
    if (gameState.pucksRemaining <= 0) {
      gameActive = false;
      setTimeout(() => {
        document.getElementById('gameOverScreen').style.display = 'block';
      }, 2500);
    }
    
    currentPuck = null;
    updateDisplay();
    
    cancelAnimationFrame(animationId);
    drawBoard();
  }

  function animateHoverPuck() {
    if (!gameActive) return;
    
    if (currentPuck || gameState.pucksRemaining === 0) {
      requestAnimationFrame(animateHoverPuck);
      return;
    }
    
    // Gentle floating animation
    const time = Date.now() * 0.002;
    hoverPuck.x = DROP_RAMP.x + DROP_RAMP.width / 2 + Math.sin(time) * (DROP_RAMP.width * 0.3);
    hoverPuck.y = DROP_RAMP.y + DROP_RAMP.height / 2 + Math.cos(time * 0.7) * 5;
    
    drawBoard();
    requestAnimationFrame(animateHoverPuck);
  }

  function updateDisplay() {
    document.getElementById('puckCounter').textContent = gameState.pucksRemaining;
    document.getElementById('currentBoard').textContent = `BOARD ${gameState.currentBoard}`;
    
    const puckCounter = document.getElementById('puckCounter');
    if (gameState.pucksRemaining <= 2) {
      puckCounter.style.color = '#FF6B6B';
    } else if (gameState.pucksRemaining <= 5) {
      puckCounter.style.color = '#FFA726';
    } else {
      puckCounter.style.color = '#FFFFFF';
    }
  }

  async function saveState() {
    try {
      await updateGameBin(binId, gameState);
    } catch (error) {
      console.error('Failed to save game state:', error);
    }
  }

  function isInDropRamp(x, y) {
    return x >= DROP_RAMP.x && 
           x <= DROP_RAMP.x + DROP_RAMP.width &&
           y >= DROP_RAMP.y && 
           y <= DROP_RAMP.y + DROP_RAMP.height;
  }

  // ==================== EVENT HANDLERS ====================
  function getCanvasCoords(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  }

  function handleStart(e) {
    if (!gameActive || currentPuck || gameState.pucksRemaining === 0) return;
    
    audioSystem.init(); // Initialize audio on first interaction
    
    const coords = getCanvasCoords(e);
    const distance = Math.sqrt(
      Math.pow(coords.x - hoverPuck.x, 2) + 
      Math.pow(coords.y - hoverPuck.y, 2)
    );
    
    if (distance < PUCK_RADIUS * 2 && isInDropRamp(coords.x, coords.y)) {
      isDragging = true;
      currentPuck = { 
        x: coords.x, 
        y: coords.y, 
        vx: 0, 
        vy: 0
      };
      gameState.lastUpdated = new Date().toISOString();
      saveState();
      drawBoard();
    }
  }

  function handleMove(e) {
    if (!gameActive) return;
    
    const coords = getCanvasCoords(e);
    
    if (isDragging && currentPuck) {
      currentPuck.x = Math.max(PUCK_RADIUS, Math.min(W - PUCK_RADIUS, coords.x));
      currentPuck.y = Math.max(PUCK_RADIUS, Math.min(H - PUCK_RADIUS, coords.y));
      drawBoard();
    } else if (gameState.pucksRemaining > 0 && !currentPuck) {
      if (isInDropRamp(coords.x, coords.y)) {
        hoverPuck.x = coords.x;
        hoverPuck.y = coords.y;
      }
    }
  }

  function handleEnd(e) {
    if (!gameActive || !isDragging || !currentPuck) return;
    
    isDragging = false;
    
    // Must release in drop ramp
    if (!isInDropRamp(currentPuck.x, currentPuck.y)) {
      const warning = document.getElementById('releaseWarning');
      warning.classList.add('show');
      setTimeout(() => warning.classList.remove('show'), 2000);
      currentPuck = null;
      drawBoard();
      return;
    }
    
    // Drop straight down with minimal initial velocity
    currentPuck.vx = 0;
    currentPuck.vy = 1; // Very small initial downward velocity
    
    audioSystem.playDrop();
    
    lastTime = performance.now();
    animationId = requestAnimationFrame(updatePhysics);
    saveState();
  }

  // Mouse events
  canvas.addEventListener('mousedown', handleStart);
  canvas.addEventListener('mousemove', handleMove);
  canvas.addEventListener('mouseup', handleEnd);
  canvas.addEventListener('mouseleave', handleEnd);
  
  // Touch events
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    handleStart(e);
  });
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    handleMove(e);
  });
  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    handleEnd(e);
  });

  // ==================== INITIALIZE ====================
  initPegs();
  updateDisplay();
  drawBoard();
  animateHoverPuck();
}
</script>
</body>
</html>
