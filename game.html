<!DOCTYPE html>
<html lang="UTF-8">
<head>
<meta charset="UTF-8">
<title>U.S. LawShield PLINKO – Classic Board Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  :root {
    --neon-blue: #00aaff;
    --neon-green: #39ff14;
    --deep-navy: #001533;
    --plinko-gold: #FFD700;
    --highlight-blue: #00e1ff;
    --hot-pink: #ff4b8a;
    --teal: #00c6b8;
  }
  
  body {
    font-family: 'Montserrat', sans-serif;
    background: radial-gradient(circle at 50% 10%, #00aaff 0%, #002244 35%, #000814 100%);
    min-height: 100vh;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  .game-container {
    width: 96vw;
    height: 96vh;
    max-width: 1100px;
    max-height: 1100px;
    position: relative;
    border-radius: 28px;
    border: 10px solid var(--plinko-gold);
    box-shadow: 0 0 90px rgba(0,0,0,0.9), 0 0 80px rgba(0,255,200,0.6);
    background: radial-gradient(circle at 50% -10%, #ffffff 0%, #ffe4f0 25%, #fbd2e7 35%, #f04f8a 45%, #b0004a 55%, #5b0022 80%);
    overflow: hidden;
  }

  .header {
    position: absolute;
    top: 0;
    width: 100%;
    height: 130px;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    background: linear-gradient(180deg, #ffe6ff 0%, #ffb6e1 40%, #ff5ea3 80%);
    border-bottom: 6px solid var(--plinko-gold);
    box-shadow: 0 0 45px rgba(255,255,255,0.9);
    z-index: 10;
  }

  .title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3.6rem;
    letter-spacing: 10px;
    text-shadow: 0 0 22px #fff, 0 0 40px var(--plinko-gold), 3px 3px 0 #ff0080;
    color: #ffffff;
    margin-bottom: 6px;
  }

  .subtitle {
    position: absolute;
    top: 112px;
    width: 100%;
    text-align: center;
    font-size: 0.9rem;
    letter-spacing: 3px;
    color: var(--plinko-gold);
    text-shadow: 0 0 10px #000;
    z-index: 10;
  }

  .canvas-wrapper {
    position: absolute;
    top: 130px;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 4px 8px 10px;
  }

  #plinkoCanvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: pointer;
    border-radius: 22px;
    box-shadow: inset 0 0 35px rgba(0,0,0,0.95);
    background: radial-gradient(circle at 50% 0%, #fdf4ff 0%, #f3e3ff 25%, #e5d2ff 40%, #cfd9ff 55%, #004e92 90%);
  }

  .game-info {
    position: absolute;
    top: 145px;
    left: 24px;
    right: 24px;
    display: flex;
    justify-content: space-between;
    z-index: 12;
    pointer-events: none;
  }

  .info-badge {
    background: linear-gradient(135deg, #ff4b8a 0%, #ffb347 100%);
    padding: 8px 18px;
    border-radius: 18px;
    border: 3px solid var(--plinko-gold);
    color: white;
    font-weight: 800;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 5px 18px rgba(0,0,0,0.6);
  }

  /* Drop ramp (top strip, not a small pill) */
  .drop-zone {
    position: absolute;
    top: 160px;
    left: 10%;
    width: 80%;
    height: 38px;
    border-radius: 24px;
    background:
      repeating-linear-gradient(
        135deg,
        rgba(255,255,255,0.12),
        rgba(255,255,255,0.12) 8px,
        rgba(255,255,255,0.01) 8px,
        rgba(255,255,255,0.01) 16px
      ),
      linear-gradient(90deg, #ff4b8a 0%, #ffd54f 50%, #00c6b8 100%);
    border: 4px solid var(--plinko-gold);
    box-shadow: 0 0 25px rgba(255,255,255,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #ffffff;
    font-weight: 800;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 3px;
    z-index: 12;
    text-shadow: 0 0 6px #000;
  }

  .instruction {
    position: absolute;
    bottom: 4px;
    left: 0; right: 0;
    text-align: center;
    color: var(--plinko-gold);
    font-weight: 700;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 3px;
    text-shadow: 0 0 10px #000;
    z-index: 10;
  }

  .release-warning {
    position: absolute;
    top: 210px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    padding: 10px 18px;
    border-radius: 14px;
    border: 3px solid var(--plinko-gold);
    color: white;
    font-weight: 700;
    font-size: 13px;
    text-align: center;
    z-index: 100;
    box-shadow: 0 10px 25px rgba(0,0,0,0.9);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.25s ease-out;
  }

  .release-warning.show {
    opacity: 1;
  }

  .error-screen {
    text-align: center;
    padding: 40px;
    background: linear-gradient(135deg, rgba(0, 34, 68, 0.9) 0%, rgba(36, 89, 152, 0.9) 100%);
    border-radius: 25px;
    border: 4px solid var(--plinko-gold);
    box-shadow: 0 15px 50px rgba(0,0,0,0.6);
  }

  .error-icon {
    font-size: 4em;
    margin-bottom: 20px;
  }

  .error-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 2.5em;
    color: var(--plinko-gold);
    margin-bottom: 15px;
    letter-spacing: 3px;
  }

  .error-message {
    font-size: 1.2em;
    color: white;
    line-height: 1.6;
  }

  .bigwin {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-size: 5.5em;
    color: var(--plinko-gold);
    text-shadow: 0 0 50px var(--plinko-gold), 0 0 100px #FF0000;
    z-index: 9999;
    pointer-events: none;
    animation: win 2s forwards;
    font-family: 'Bebas Neue', sans-serif;
    letter-spacing: 6px;
  }

  @keyframes win {
    0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.25) rotate(8deg); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }

  .game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #ffb6e1 0%, #ff4b8a 90%);
    padding: 30px 40px;
    border-radius: 20px;
    border: 4px solid var(--plinko-gold);
    color: white;
    text-align: center;
    z-index: 100;
    box-shadow: 0 15px 40px rgba(0,0,0,0.8);
    display: none;
  }

  .game-over h2 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    margin-bottom: 15px;
    letter-spacing: 3px;
    color: var(--plinko-gold);
    text-shadow: 0 0 20px #fff;
  }

  .slot-values {
    position: absolute;
    bottom: 40px;
    left: 0;
    width: 100%;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3em;
    color: #fff;
    text-align: center;
    letter-spacing: 3px;
    display: flex;
    justify-content: space-evenly;
    text-shadow: 0 0 10px #000;
    pointer-events: none;
    z-index: 15;
  }

  .slot-values span.jackpot {
    color: var(--plinko-gold);
    text-shadow: 0 0 15px var(--plinko-gold), 0 0 25px var(--neon-green);
    font-size: 1.5em;
  }

</style>
</head>
<body>
<div class="game-container" id="gameContainer">
  <div class="header">
    <h1 class="title">PLINKO</h1>
  </div>
  <p class="subtitle">U.S. LAWSHIELD • LEGAL DEFENSE FOR SELF DEFENSE®</p>

  <div class="canvas-wrapper">
    <div class="game-info">
      <div class="info-badge" id="currentBoard">BOARD A</div>
      <div class="info-badge">PUCKS: <span id="puckCounter">0</span></div>
    </div>

    <!-- Drop "ramp" – where contestants line up the puck -->
    <div class="drop-zone">LINE UP YOUR PUCK ALONG THE RAMP</div>

    <canvas id="plinkoCanvas" width="800" height="1000"></canvas>
    <div class="release-warning" id="releaseWarning">⚠️ RELEASE WHILE OVER THE RAMP!</div>
    <div class="game-over" id="gameOverScreen">
      <h2>GAME COMPLETE!</h2>
      <p>All pucks have been used.</p>
      <p>Thank you for playing!</p>
    </div>
    <div class="slot-values" id="slotVals"></div>
    <div class="instruction">DRAG PUCK ALONG TOP RAMP → RELEASE TO PLAY!</div>
  </div>
</div>

<script>
// JSONBin config
const JSONBIN_CONFIG = {
  BASE_URL: 'https://api.jsonbin.io/v3/b',
  HEADERS: {
    'Content-Type': 'application/json',
    'X-Master-Key': '$2a$10$NckuWO.y9g8.amyZZWkc8.lKIMS.AVSCyN1qT9/0d5EtRjuV9lmS2',
    'X-Access-Key': '$2a$10$g6RfQ66H6XQyYy3D848Cfurvs0dXgVt92aV0Rr0UqchZrBZwr7Vpy'
  }
};

const urlParams = new URLSearchParams(window.location.search);
const binId = urlParams.get('game');

if (!binId) {
  showError();
} else {
  initGame(binId);
}

function showError() {
  document.getElementById('gameContainer').innerHTML = `
    <div class="error-screen">
      <div class="error-icon">⚠️</div>
      <h2 class="error-title">INVALID SESSION</h2>
      <p class="error-message">
        This game link is invalid or has expired.<br>
        Please contact the administrator for a new game link.
      </p>
    </div>
  `;
}

async function updateGameBin(binId, data) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}`, {
      method: 'PUT',
      headers: JSONBIN_CONFIG.HEADERS,
      body: JSON.stringify(data)
    });
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    return await response.json();
  } catch (error) {
    console.error('Error updating JSONBin:', error);
    throw error;
  }
}

async function readGameBin(binId) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_CONFIG.HEADERS['X-Master-Key'],
        'X-Access-Key': JSONBIN_CONFIG.HEADERS['X-Access-Key']
      }
    });
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();
    return data.record;
  } catch (error) {
    console.error('Error reading from JSONBin:', error);
    return null;
  }
}

async function initGame(binId) {
  try {
    const gameState = await readGameBin(binId);
    if (!gameState) throw new Error('Failed to load game');
    gameState.playerConnected = true;
    gameState.lastUpdated = new Date().toISOString();
    await updateGameBin(binId, gameState);
    startPlinko(binId, gameState);
  } catch (error) {
    console.error('Error loading game:', error);
    showError();
  }
}

// ---- PLINKO CORE ----
function startPlinko(binId, gameState) {
  const canvas = document.getElementById('plinkoCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  const DROP_ZONE_Y = 160;
  const DROP_ZONE_HEIGHT = 38;
  const DROP_ZONE_LEFT = W * 0.10;
  const DROP_ZONE_RIGHT = W * 0.90;
  const DROP_ZONE_CENTER = W / 2;

  const PUCK_RADIUS = 18;
  const PEG_RADIUS = 6;
  const NUM_ROWS = 12;
  const NUM_SLOTS = 9;
  const PEG_COLS = 13; // more pegs like real board

  let pegs = [];
  let currentPuck = null;
  let isDragging = false;
  let hoverPuck = { x: DROP_ZONE_CENTER, y: DROP_ZONE_Y + DROP_ZONE_HEIGHT / 2 };
  let animationId = null;
  let particles = [];
  let lastTime = 0;
  let gameActive = true;

  const SLOT_VALUES = {
    A: [100, 500, 1000, 0, 10000, 0, 1000, 500, 100],
    B: [0, 300, 600, 1000, 5000, 1000, 600, 300, 0]
  };

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playPegSound() {
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.value = 550 + Math.random() * 200;
      gain.gain.value = 0.05;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.06);
    } catch (e) {}
  }

  // Full triangular peg grid (no patches)
  function initPegs() {
    pegs = [];
    const boardLeft = 80;
    const boardRight = W - 80;
    const boardWidth = boardRight - boardLeft;

    const startY = DROP_ZONE_Y + DROP_ZONE_HEIGHT + 55;
    const rowHeight = (H - startY - 190) / NUM_ROWS;

    for (let row = 0; row < NUM_ROWS; row++) {
      const colsThisRow = PEG_COLS - (row % 2); // 13,12,13,12...
      const spacingX = boardWidth / (PEG_COLS - 1);
      const rowY = startY + row * rowHeight;

      const totalSpan = spacingX * (colsThisRow - 1);
      const rowLeft = W / 2 - totalSpan / 2;

      for (let c = 0; c < colsThisRow; c++) {
        const x = rowLeft + c * spacingX;
        pegs.push({ x, y: rowY, lastHit: 0 });
      }
    }
  }

  function drawSideStripes() {
    const stripeCount = 9;
    const stripeWidth = W * 0.22;
    const centerX = -W * 0.1;
    const centerXRight = W * 1.1;
    const topY = 30;
    const bottomY = H - 40;

    for (let i = 0; i < stripeCount; i++) {
      const color = i % 2 === 0 ? "#ff4b8a" : "#00c6b8";
      const angleOffset = (i - (stripeCount - 1) / 2) * (Math.PI / 18);

      ctx.save();
      ctx.translate(centerX, H / 2);
      ctx.rotate(angleOffset);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0, -stripeWidth / 2);
      ctx.lineTo(stripeWidth, -stripeWidth / 4);
      ctx.lineTo(stripeWidth, stripeWidth / 4);
      ctx.lineTo(0, stripeWidth / 2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.translate(centerXRight, H / 2);
      ctx.rotate(-angleOffset);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0, -stripeWidth / 2);
      ctx.lineTo(-stripeWidth, -stripeWidth / 4);
      ctx.lineTo(-stripeWidth, stripeWidth / 4);
      ctx.lineTo(0, stripeWidth / 2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  function drawSlots() {
    const slotHeight = 135;
    const slotY = H - slotHeight;
    const slotWidth = W / NUM_SLOTS;
    const vanishingCenter = W / 2;
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;

    ctx.save();
    for (let index = 0; index < NUM_SLOTS; index++) {
      const x0 = index * slotWidth;
      const x1 = x0 + slotWidth;
      const slotCenter = (x0 + x1) / 2;
      const offset = (slotCenter - vanishingCenter) / (W / 2);
      const skew = offset * 0.25; // bigger tilt for more "curved" look

      const value = currentSlotValues[index];
      const gradient = ctx.createLinearGradient(x0, slotY, x1, slotY + slotHeight);
      if (value === 10000 || value === 5000) {
        gradient.addColorStop(0, "#ffd700");
        gradient.addColorStop(1, "#ffb347");
      } else if (value === 0) {
        gradient.addColorStop(0, "#444");
        gradient.addColorStop(1, "#111");
      } else {
        gradient.addColorStop(0, "#ff4b8a");
        gradient.addColorStop(1, "#8b0000");
      }

      ctx.save();
      ctx.transform(1, 0, skew, 1, 0, 0);
      ctx.fillStyle = gradient;
      ctx.fillRect(x0, slotY, slotWidth, slotHeight);
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = value === 10000 || value === 5000 ? 5 : 3;
      ctx.strokeRect(x0, slotY, slotWidth, slotHeight);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawBoard() {
    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, "#fef5ff");
    bgGrad.addColorStop(0.3, "#ffeaf7");
    bgGrad.addColorStop(0.6, "#f0e7ff");
    bgGrad.addColorStop(1, "#002a66");
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    drawSideStripes();

    ctx.strokeStyle = "#FFD700";
    ctx.lineWidth = 6;
    ctx.strokeRect(70, 35, W - 140, H - 80);

    ctx.shadowColor = "#FFD700";
    ctx.shadowBlur = 8;
    pegs.forEach(peg => {
      const pegGrad = ctx.createRadialGradient(peg.x - 2, peg.y - 2, 0, peg.x, peg.y, PEG_RADIUS);
      pegGrad.addColorStop(0, "#ffffff");
      pegGrad.addColorStop(0.4, "#ffe066");
      pegGrad.addColorStop(1, "#ff8c00");
      ctx.fillStyle = pegGrad;
      ctx.beginPath();
      ctx.arc(peg.x, peg.y, PEG_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.beginPath();
      ctx.arc(peg.x - 2, peg.y - 2, PEG_RADIUS * 0.3, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.shadowBlur = 0;

    drawSlots();

    if (currentPuck) {
      drawPuck(currentPuck.x, currentPuck.y, false);
    } else if (gameState.pucksRemaining > 0 && !isDragging) {
      drawPuck(hoverPuck.x, hoverPuck.y, true);
    }

    particles.forEach((p, idx) => {
      p.life--;
      if (p.life <= 0) return;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.12;
      ctx.globalAlpha = p.life / p.maxLife;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });
    particles = particles.filter(p => p.life > 0);
  }

  function drawPuck(x, y, isHover) {
    ctx.save();
    ctx.shadowColor = isHover ? "#00ffcc" : "#ff004c";
    ctx.shadowBlur = isHover ? 18 : 12;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    const grad = ctx.createRadialGradient(x - 6, y - 6, 0, x, y, PUCK_RADIUS);
    if (isHover) {
      grad.addColorStop(0, "#ffffff");
      grad.addColorStop(0.3, "#00ffcc");
      grad.addColorStop(0.7, "#00aaff");
      grad.addColorStop(1, "#004e92");
    } else {
      grad.addColorStop(0, "#ffffff");
      grad.addColorStop(0.3, "#ff4b81");
      grad.addColorStop(0.8, "#ff004c");
      grad.addColorStop(1, "#8b0000");
    }

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#FFD700";
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.beginPath();
    ctx.arc(x - 5, y - 5, PUCK_RADIUS * 0.3, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#ffffff";
    ctx.font = "bold 12px Montserrat";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("USL", x, y);
    ctx.restore();
  }

  function updatePhysics(timestamp) {
    if (!currentPuck || !gameActive) return;
    const deltaTime = Math.min(20, timestamp - lastTime) / 16;
    lastTime = timestamp;

    currentPuck.vy += 0.45 * deltaTime;
    currentPuck.x += currentPuck.vx * deltaTime;
    currentPuck.y += currentPuck.vy * deltaTime;

    currentPuck.vx *= 0.999;
    currentPuck.vy *= 0.999;

    if (currentPuck.x - PUCK_RADIUS < 70) {
      currentPuck.x = 70 + PUCK_RADIUS;
      currentPuck.vx = Math.abs(currentPuck.vx) * 0.85;
    } else if (currentPuck.x + PUCK_RADIUS > W - 70) {
      currentPuck.x = W - 70 - PUCK_RADIUS;
      currentPuck.vx = -Math.abs(currentPuck.vx) * 0.85;
    }

    const now = Date.now();
    pegs.forEach(peg => {
      if (now - peg.lastHit < 40) return;
      const dx = currentPuck.x - peg.x;
      const dy = currentPuck.y - peg.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = PUCK_RADIUS + PEG_RADIUS;
      if (dist < minDist) {
        peg.lastHit = now;
        const nx = dx / (dist || 0.0001);
        const ny = dy / (dist || 0.0001);
        const overlap = (minDist - dist) || 0.5;
        currentPuck.x += nx * overlap * 0.6;
        currentPuck.y += ny * overlap * 0.6;

        const dot = currentPuck.vx * nx + currentPuck.vy * ny;
        currentPuck.vx -= 1.9 * dot * nx;
        currentPuck.vy -= 1.9 * dot * ny;

        currentPuck.vx += (Math.random() - 0.5) * 0.7;
        currentPuck.vy += (Math.random() - 0.5) * 0.5;

        for (let i = 0; i < 4; i++) {
          particles.push({
            x: currentPuck.x,
            y: currentPuck.y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 18,
            maxLife: 18,
            size: Math.random() * 2.2 + 1,
            color: "#FFD700"
          });
        }
        playPegSound();
      }
    });

    if (currentPuck.y + PUCK_RADIUS > H - 135) {
      handlePuckLanding();
      return;
    }

    drawBoard();
    animationId = requestAnimationFrame(updatePhysics);
  }

  function handlePuckLanding() {
    const slotWidth = W / NUM_SLOTS;
    const slotIndex = Math.min(NUM_SLOTS - 1, Math.max(0, Math.floor(currentPuck.x / slotWidth)));
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;
    const slotValue = currentSlotValues[slotIndex];

    if (!gameState.results) gameState.results = [];
    gameState.results.push({
      board: gameState.currentBoard,
      slot: slotIndex,
      value: slotValue,
      timestamp: Date.now()
    });

    const particleCount = slotValue >= 1000 ? 90 : 40;
    const color = slotValue >= 5000 ? "#FFD700" : slotValue >= 1000 ? "#00ffcc" : "#888888";
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: currentPuck.x,
        y: H - 80,
        vx: (Math.random() - 0.5) * 10,
        vy: -Math.random() * 12,
        life: 50,
        maxLife: 50,
        size: Math.random() * 3.5 + 2,
        color
      });
    }

    if (slotValue === 10000 || slotValue === 5000) {
      const winElement = document.createElement('div');
      winElement.className = 'bigwin';
      winElement.textContent = slotValue === 10000 ? 'JACKPOT!' : 'BIG WIN!';
      document.body.appendChild(winElement);
      setTimeout(() => winElement.remove(), 2500);
    }

    gameState.pucksRemaining--;
    gameState.lastUpdated = new Date().toISOString();

    saveState();

    if (gameState.boardConfig === 'BOTH' &&
        gameState.currentBoard === 'A' &&
        gameState.pucksRemaining <= gameState.puckCountB) {
      gameState.currentBoard = 'B';
      document.getElementById('currentBoard').textContent = 'BOARD B';
      initPegs();
      updateSlotText();
    }

    if (gameState.pucksRemaining <= 0) {
      gameActive = false;
      setTimeout(() => {
        document.getElementById('gameOverScreen').style.display = 'block';
      }, 2000);
    }

    currentPuck = null;
    updateDisplay();
    cancelAnimationFrame(animationId);
    drawBoard();
  }

  function animateHoverPuck() {
    if (!gameActive) return;
    if (currentPuck || gameState.pucksRemaining === 0) {
      requestAnimationFrame(animateHoverPuck);
      return;
    }
    const time = Date.now() * 0.002;
    const margin = 40;
    const left = DROP_ZONE_LEFT + margin;
    const right = DROP_ZONE_RIGHT - margin;
    const span = right - left;
    hoverPuck.x = left + (Math.sin(time) * 0.5 + 0.5) * span;
    hoverPuck.y = DROP_ZONE_Y + DROP_ZONE_HEIGHT / 2;
    drawBoard();
    requestAnimationFrame(animateHoverPuck);
  }

  function updateDisplay() {
    document.getElementById('puckCounter').textContent = gameState.pucksRemaining;
    document.getElementById('currentBoard').textContent = `BOARD ${gameState.currentBoard}`;
    const puckCounterEl = document.getElementById('puckCounter');
    if (gameState.pucksRemaining <= 2) {
      puckCounterEl.style.color = '#ff6b6b';
    } else if (gameState.pucksRemaining <= 5) {
      puckCounterEl.style.color = '#ffb347';
    } else {
      puckCounterEl.style.color = '#ffffff';
    }
  }

  async function saveState() {
    try {
      await updateGameBin(binId, gameState);
    } catch (error) {
      console.error('Failed to save game state:', error);
    }
  }

  function isInDropZone(x, y) {
    return (
      x >= DROP_ZONE_LEFT &&
      x <= DROP_ZONE_RIGHT &&
      y >= DROP_ZONE_Y &&
      y <= DROP_ZONE_Y + DROP_ZONE_HEIGHT
    );
  }

  canvas.addEventListener('mousemove', (e) => {
    if (!gameActive) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    if (isDragging && currentPuck) {
      currentPuck.x = Math.max(DROP_ZONE_LEFT + PUCK_RADIUS, Math.min(DROP_ZONE_RIGHT - PUCK_RADIUS, x));
      currentPuck.y = DROP_ZONE_Y + DROP_ZONE_HEIGHT / 2;
      drawBoard();
    } else if (gameState.pucksRemaining > 0 && !currentPuck) {
      hoverPuck.x = Math.max(DROP_ZONE_LEFT + PUCK_RADIUS, Math.min(DROP_ZONE_RIGHT - PUCK_RADIUS, x));
      hoverPuck.y = DROP_ZONE_Y + DROP_ZONE_HEIGHT / 2;
    }
  });

  canvas.addEventListener('mousedown', (e) => {
    if (!gameActive || currentPuck || gameState.pucksRemaining === 0) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    const distance = Math.sqrt(Math.pow(x - hoverPuck.x, 2) + Math.pow(y - hoverPuck.y, 2));
    if (distance < PUCK_RADIUS * 1.7 && isInDropZone(x, y)) {
      isDragging = true;
      currentPuck = { x, y, vx: 0, vy: 0 };
      gameState.lastUpdated = new Date().toISOString();
      saveState();
      drawBoard();
    }
  });

  canvas.addEventListener('mouseup', () => {
    if (!gameActive || !isDragging || !currentPuck) return;
    isDragging = false;
    if (!isInDropZone(currentPuck.x, currentPuck.y)) {
      const warning = document.getElementById('releaseWarning');
      warning.classList.add('show');
      setTimeout(() => warning.classList.remove('show'), 2000);
      currentPuck = null;
      drawBoard();
      return;
    }

    currentPuck.vx = 0;      // straight down from ramp
    currentPuck.vy = 2.5;

    lastTime = performance.now();
    requestAnimationFrame(updatePhysics);
    saveState();
  });

  function updateSlotText() {
    const slotValsEl = document.getElementById('slotVals');
    const currentSlotValues = SLOT_VALUES[gameState.currentBoard] || SLOT_VALUES.A;
    slotValsEl.innerHTML = currentSlotValues.map(v => {
      if (v === 0) return `<span>0</span>`;
      if (v === 10000 || v === 5000) return `<span class="jackpot">$${v.toLocaleString()}</span>`;
      return `<span>$${v}</span>`;
    }).join('');
  }

  initPegs();
  updateDisplay();
  updateSlotText();
  drawBoard();
  animateHoverPuck();
}
</script>
</body>
</html>
