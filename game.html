<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>U.S. LawShield PLINKO</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@700;800&display=swap" rel="stylesheet">
<style>
  * { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
  }
  
  body {
    font-family: 'Montserrat', sans-serif;
    background: #1a1a2e;
    min-height: 100vh;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    gap: 30px;
  }

  body.loading {
    opacity: 0.7;
    pointer-events: none;
  }

  .side-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 280px;
  }

  .header {
    background: #FF1744;
    padding: 25px 20px;
    border: 6px solid #00BCD4;
    text-align: center;
  }

  .title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 2.5em;
    letter-spacing: 6px;
    color: white;
    text-shadow: 3px 3px 0 #000;
  }

  .subtitle {
    font-size: 0.9em;
    letter-spacing: 2px;
    margin-top: 8px;
    font-weight: 800;
  }

  .puck-holder {
    background: #FF1744;
    border: 6px solid #00BCD4;
    padding: 30px;
    text-align: center;
    min-height: 200px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
  }

  .puck-holder-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.8em;
    letter-spacing: 3px;
    color: white;
  }

  .puck-holder-canvas {
    cursor: grab;
    transition: transform 0.2s ease;
  }

  .puck-holder-canvas:active {
    cursor: grabbing;
    transform: scale(0.95);
  }

  .puck-holder-canvas:disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }

  .has-pucks {
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }

  .info-badge {
    background: #FF1744;
    padding: 20px;
    border: 6px solid #00BCD4;
    color: white;
    font-weight: 800;
    font-size: 20px;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-align: center;
  }

  .legend-panel {
    background: #FF1744;
    border: 6px solid #00BCD4;
    padding: 20px;
    max-height: 500px;
    overflow-y: auto;
  }

  .legend-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.8em;
    color: white;
    margin-bottom: 15px;
    text-align: center;
    letter-spacing: 3px;
  }

  .prize-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px;
    margin-bottom: 8px;
    background: rgba(0, 0, 0, 0.2);
    border-left: 5px solid;
  }

  .prize-symbol {
    font-size: 1.8em;
    min-width: 35px;
    text-align: center;
  }

  .prize-name {
    font-size: 0.85em;
    font-weight: 700;
    line-height: 1.3;
    color: white;
  }

  .game-container {
    position: relative;
    width: 70vw;
    height: 100vh;
    max-width: 900px;
    max-height: 1600px;
  }

  .canvas-wrapper {
    width: 100%;
    height: 100%;
    position: relative;
    background: #F5E6D3;
    border: 10px solid #FF1744;
    box-shadow: 0 0 0 4px #00BCD4, 0 0 0 8px white;
    overflow: hidden;
  }

  #plinkoCanvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  .game-info-top {
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    display: flex;
    justify-content: space-between;
    z-index: 10;
    pointer-events: none;
  }

  .top-badge {
    background: #FF1744;
    padding: 12px 20px;
    border: 4px solid white;
    color: white;
    font-weight: 800;
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
  }

  .win-announcement {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: #FF1744;
    border: 10px solid #00BCD4;
    padding: 60px 50px;
    text-align: center;
    z-index: 10000;
    max-width: 500px;
    box-shadow: 0 0 100px rgba(0, 0, 0, 0.8);
  }

  .win-announcement.show {
    animation: winShow 0.4s forwards;
  }

  @keyframes winShow {
    0% { transform: translate(-50%, -50%) scale(0); }
    100% { transform: translate(-50%, -50%) scale(1); }
  }

  .win-symbol {
    font-size: 5em;
    margin-bottom: 20px;
  }

  .win-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    color: white;
    margin-bottom: 15px;
    letter-spacing: 4px;
    text-shadow: 3px 3px 0 #000;
  }

  .win-prize {
    font-size: 1.4em;
    font-weight: 800;
    line-height: 1.4;
    margin-bottom: 25px;
    color: white;
  }

  .win-stats {
    font-size: 1em;
    font-weight: 600;
    margin-bottom: 20px;
    color: #00BCD4;
  }

  .win-close {
    background: #00BCD4;
    color: white;
    border: none;
    padding: 15px 40px;
    font-size: 1.3em;
    font-weight: 800;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 2px;
    font-family: 'Bebas Neue', sans-serif;
  }

  .win-close:hover {
    background: #00ACC1;
  }

  .game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #FF1744;
    border: 10px solid #00BCD4;
    padding: 50px;
    text-align: center;
    z-index: 100;
    display: none;
  }

  .game-over h2 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    color: white;
    margin-bottom: 20px;
    letter-spacing: 4px;
  }

  .game-over p {
    font-size: 1.3em;
    font-weight: 700;
    margin-bottom: 10px;
  }

  .error-screen {
    text-align: center;
    padding: 60px;
    background: #FF1744;
    border: 10px solid #00BCD4;
    max-width: 600px;
  }

  .error-icon {
    font-size: 5em;
    margin-bottom: 20px;
  }

  .error-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 3em;
    color: white;
    margin-bottom: 20px;
    letter-spacing: 4px;
  }

  .error-message {
    font-size: 1.3em;
    line-height: 1.6;
  }

  @media (max-width: 768px) {
    body {
      flex-direction: column;
      padding: 10px;
      gap: 15px;
    }
    
    .side-panel {
      width: 100%;
      max-width: 400px;
    }
    
    .game-container {
      width: 95vw;
      height: 70vh;
    }
    
    .title {
      font-size: 2em;
    }
  }
</style>
</head>
<body>
<div class="side-panel">
  <div class="header">
    <h1 class="title">U.S. LAWSHIELD</h1>
    <p class="subtitle">PLINKO GAME</p>
  </div>

  <div class="puck-holder">
    <div class="puck-holder-title">GRAB PUCK</div>
    <canvas id="puckHolderCanvas" width="120" height="120" class="puck-holder-canvas"></canvas>
  </div>

  <div class="info-badge">
    <div>BOARD: <span id="currentBoard">A</span></div>
    <div style="margin-top: 8px;">PUCKS: <span id="puckCounter">0</span></div>
  </div>

  <div class="legend-panel">
    <div class="legend-title">PRIZES</div>
    <div id="legendContent"></div>
  </div>
</div>

<div class="game-container" id="gameContainer">
  <div class="canvas-wrapper">
    <canvas id="plinkoCanvas"></canvas>
    <div class="game-over" id="gameOverScreen">
      <h2>GAME COMPLETE!</h2>
      <p>All pucks have been played.</p>
      <p>Thank you for participating!</p>
    </div>
  </div>
</div>

<div class="win-announcement" id="winAnnouncement">
  <div class="win-symbol" id="winSymbol"></div>
  <div class="win-title">YOU WON!</div>
  <div class="win-prize" id="winPrize"></div>
  <div class="win-stats" id="winStats"></div>
  <button class="win-close" onclick="closeWinAnnouncement()">CONTINUE</button>
</div>

<script>
// ==================== PRIZE CONFIGURATION ====================
const PRIZE_CONFIG = {
  A: {
    name: "Board A",
    prizes: [
      { symbol: 'üéÅ', name: '$25 Gift Card', color: '#FF4081' },
      { symbol: '‚è∞', name: '1 Hour Campaign of Your Choice', color: '#00BCD4' },
      { symbol: 'üë•', name: 'Shadow an Agent for 1 Hour', color: '#FF4081' },
      { symbol: 'üö™', name: 'Leave 15min Early / Come in 15min Late', color: '#00BCD4' },
      { symbol: '‚òï', name: 'Extra 15 Minute Break', color: '#FFFFFF' },
      { symbol: 'üìä', name: 'Replace QA Score with Call of Your Choice', color: '#00BCD4' },
      { symbol: 'üíº', name: 'Coffee with Leadership', color: '#FF4081' },
      { symbol: '‚è∞', name: '1 Hour Campaign of Your Choice', color: '#00BCD4' },
      { symbol: 'üéÅ', name: '$25 Gift Card', color: '#FF4081' }
    ]
  },
  B: {
    name: "Board B",
    prizes: [
      { symbol: 'üïë', name: '2 Hours Campaign of Your Choice', color: '#9C27B0' },
      { symbol: 'üí∞', name: '$50 Gift Card', color: '#FF5722' },
      { symbol: '‚è±Ô∏è', name: 'Leave 30 Minutes Early', color: '#2196F3' },
      { symbol: 'üíØ', name: 'Replace Lowest QA Score with 100', color: '#4CAF50' },
      { symbol: 'üïì', name: '4 Hours Campaign of Your Choice', color: '#FFC107' },
      { symbol: 'üçΩÔ∏è', name: 'Lunch on Leadership', color: '#FF9800' },
      { symbol: 'üé¥', name: 'Wild Card', color: '#00BCD4' },
      { symbol: 'üí∞', name: '$50 Gift Card', color: '#FF5722' },
      { symbol: 'üïë', name: '2 Hours Campaign of Your Choice', color: '#9C27B0' }
    ]
  }
};

// ==================== CONFIGURATION ====================
const JSONBIN_CONFIG = {
  BASE_URL: 'https://api.jsonbin.io/v3/b',
  HEADERS: {
    'Content-Type': 'application/json',
    'X-Master-Key': '$2a$10$RKQHusd9D3WIzERQBzwFC.KOpKHvEzT8.MIGGqceg5GyTT.YfIpk6',
    'X-Access-Key': '$2a$10$sUTX2utrrPnHXKLkvPRrvea57/mv64FybLk3ythIqvzGB9TcGQgS6'
  }
};

// ==================== AUDIO SYSTEM ====================
class AudioSystem {
  constructor() {
    this.audioContext = null;
    this.initialized = false;
  }

  init() {
    if (this.initialized) return;
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.initialized = true;
    } catch (e) {
      console.log('Audio not available');
    }
  }

  playPegHit(intensity = 0.5) {
    if (!this.initialized) return;
    
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    
    const osc1 = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    
    const baseFreq1 = 180 + (intensity * 100);
    const baseFreq2 = 220 + (intensity * 80);
    
    osc1.frequency.setValueAtTime(baseFreq1, now);
    osc1.frequency.exponentialRampToValueAtTime(120, now + 0.1);
    
    osc2.frequency.setValueAtTime(baseFreq2, now);
    osc2.frequency.exponentialRampToValueAtTime(150, now + 0.08);
    
    osc1.type = 'sine';
    osc2.type = 'triangle';
    
    filter.frequency.setValueAtTime(300, now);
    filter.type = 'bandpass';
    filter.Q.setValueAtTime(2, now);
    
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.08 * intensity, now + 0.001);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
    
    osc1.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);
    
    osc1.start(now);
    osc2.start(now);
    osc1.stop(now + 0.12);
    osc2.stop(now + 0.12);
  }

  playWin() {
    if (!this.initialized) return;
    
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    
    for (let i = 0; i < 6; i++) {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      const freq = 300 + (i * 120);
      osc.frequency.setValueAtTime(freq, now + i * 0.08);
      osc.type = 'sine';
      
      gain.gain.setValueAtTime(0, now + i * 0.08);
      gain.gain.linearRampToValueAtTime(0.15, now + i * 0.08 + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.4);
      
      osc.connect(gain);
      gain.connect(ctx.destination);
      
      osc.start(now + i * 0.08);
      osc.stop(now + i * 0.08 + 0.4);
    }
  }

  playDropSound() {
    if (!this.initialized) return;
    
    const ctx = this.audioContext;
    const now = ctx.currentTime;
    
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);
    
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.1, now + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    osc.start(now);
    osc.stop(now + 0.3);
  }
}

const audioSystem = new AudioSystem();

// ==================== GAME INITIALIZATION ====================
const urlParams = new URLSearchParams(window.location.search);
const binId = urlParams.get('game');

if (!binId) {
  showError('No game ID provided in URL');
} else {
  initGame(binId);
}

function showError(message) {
  console.error('ERROR:', message);
  document.body.innerHTML = `
    <div class="error-screen">
      <div class="error-icon">‚ö†Ô∏è</div>
      <h2 class="error-title">GAME ERROR</h2>
      <p class="error-message">
        ${message}<br><br>
        <strong>Game ID:</strong> ${binId || 'Not provided'}<br>
        <strong>Check console for details</strong>
      </p>
    </div>
  `;
}

async function initGame(binId) {
  try {
    console.log('Loading game with ID:', binId);
    
    document.body.classList.add('loading');
    
    const gameState = await readGameBin(binId);
    
    if (!gameState) {
      throw new Error('Game state is null - bin may not exist or API keys may be invalid');
    }
    
    if (!gameState.currentBoard) {
      gameState.currentBoard = 'A';
    }
    
    if (typeof gameState.pucksRemaining !== 'number') {
      throw new Error('Invalid game state - pucksRemaining is not a number');
    }
    
    if (!gameState.results) {
      gameState.results = [];
    }
    
    gameState.playerConnected = true;
    gameState.lastUpdated = new Date().toISOString();
    
    await updateGameBin(binId, gameState);
    
    document.body.classList.remove('loading');
    
    startPlinko(binId, gameState);
    
  } catch (error) {
    console.error('Error in initGame:', error);
    document.body.classList.remove('loading');
    showError(error.message);
  }
}

async function updateGameBin(binId, data) {
  try {
    console.log('Updating bin:', binId, 'with data:', data);
    
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}`, {
      method: 'PUT',
      headers: JSONBIN_CONFIG.HEADERS,
      body: JSON.stringify(data)
    });
    
    console.log('Update response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Update error:', errorText);
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }
    
    const result = await response.json();
    console.log('Update successful:', result);
    return result;
  } catch (error) {
    console.error('Error updating JSONBin:', error);
    throw error;
  }
}

async function readGameBin(binId) {
  try {
    console.log('Fetching from JSONBin:', `${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`);
    
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_CONFIG.HEADERS['X-Master-Key'],
        'X-Access-Key': JSONBIN_CONFIG.HEADERS['X-Access-Key']
      }
    });
    
    console.log('Response status:', response.status);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('API Error Response:', errorText);
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    console.log('Raw API response:', data);
    
    if (!data.record) {
      console.error('No record field in response');
      throw new Error('Invalid API response - missing record field');
    }
    
    return data.record;
  } catch (error) {
    console.error('Error in readGameBin:', error);
    return null;
  }
}

function closeWinAnnouncement() {
  document.getElementById('winAnnouncement').classList.remove('show');
}

function showTemporaryMessage(message, duration = 2000) {
  const messageEl = document.createElement('div');
  messageEl.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px 40px;
    border-radius: 10px;
    z-index: 10000;
    font-weight: bold;
    font-size: 1.2em;
  `;
  messageEl.textContent = message;
  document.body.appendChild(messageEl);
  
  setTimeout(() => {
    if (messageEl.parentNode) {
      document.body.removeChild(messageEl);
    }
  }, duration);
}

// ==================== MAIN PLINKO GAME ====================
function startPlinko(binId, gameState) {
  const canvas = document.getElementById('plinkoCanvas');
  const ctx = canvas.getContext('2d');
  
  const holderCanvas = document.getElementById('puckHolderCanvas');
  const holderCtx = holderCanvas.getContext('2d');
  
  updateLegend(gameState.currentBoard);
  
  // Fixed configuration
  const NUM_ROWS = 13;
  
  const getCurrentPrizes = () => PRIZE_CONFIG[gameState.currentBoard].prizes;
  
  let pegs = [];
  let teeth = [];
  let lastRowPegPositions = [];
  let currentPuck = null;
  let isDragging = false;
  let animationId = null;
  let particles = [];
  let lastTime = 0;
  let gameActive = true;
  let W, H;
  let canDragPuck = true;
  let needsRedraw = true;
  
  // Dynamic sizing variables
  let PUCK_RADIUS, PEG_RADIUS, PEG_SPACING_X, PEG_SPACING_Y;
  let BOARD_TOP, BOARD_BOTTOM, BOARD_LEFT, BOARD_RIGHT;
  
  const resizeCanvas = () => {
    const container = canvas.parentElement;
    const rect = container.getBoundingClientRect();
    canvas.width = W = rect.width;
    canvas.height = H = rect.height;
    
    // Calculate the dynamic play area based on available space
    const numSlots = getCurrentPrizes().length;
    
    // Define margins as percentages of canvas dimensions
    const MARGIN_TOP = H * 0.10;
    const MARGIN_BOTTOM = H * 0.15;
    const MARGIN_SIDES = W * 0.05;
    
    // Calculate play area boundaries
    BOARD_LEFT = MARGIN_SIDES;
    BOARD_RIGHT = W - MARGIN_SIDES;
    BOARD_TOP = MARGIN_TOP;
    BOARD_BOTTOM = H - MARGIN_BOTTOM;
    
    // Calculate available play area
    const playAreaWidth = BOARD_RIGHT - BOARD_LEFT;
    const playAreaHeight = BOARD_BOTTOM - BOARD_TOP;
    
    // Calculate dynamic spacing based on play area
    PEG_SPACING_X = playAreaWidth / (numSlots + 0.5);
    PEG_SPACING_Y = playAreaHeight / (NUM_ROWS - 1);
    
    // Calculate puck and peg sizes relative to spacing
    PUCK_RADIUS = Math.min(PEG_SPACING_X * 0.35, PEG_SPACING_Y * 0.35);
    PEG_RADIUS = PUCK_RADIUS * 0.22;
    
    if (gameActive) {
      initPegs();
      drawBoard();
    }
  };
  
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  
  function initPegs() {
    pegs = [];
    teeth = [];
    lastRowPegPositions = [];
    
    const numSlots = getCurrentPrizes().length;
    
    // Calculate the starting position to perfectly center the peg arrangement
    const totalWidth = (numSlots - 1) * PEG_SPACING_X;
    const startX = (W - totalWidth) / 2;
    
    for (let row = 0; row < NUM_ROWS; row++) {
      const isOffsetRow = row % 2 === 1;
      const numPegs = isOffsetRow ? numSlots - 1 : numSlots;
      const rowY = BOARD_TOP + row * PEG_SPACING_Y;
      
      if (isOffsetRow) {
        // Offset rows (7 pegs) - positioned between pegs of row above
        const rowStartX = startX + PEG_SPACING_X / 2;
        
        for (let col = 0; col < numPegs; col++) {
          const x = rowStartX + col * PEG_SPACING_X;
          const y = rowY;
          
          pegs.push({
            x: x,
            y: y,
            lastHit: 0
          });
        }
        
        // Create teeth for offset rows (7-pegs rows)
        const prevRowY = BOARD_TOP + (row - 1) * PEG_SPACING_Y;
        const nextRowY = BOARD_TOP + (row + 1) * PEG_SPACING_Y;
        
        // Calculate tooth depth based on available space
        const toothDepth = PEG_SPACING_X * 0.6;
        
        // Left tooth - peak at the position where a peg would be
        teeth.push({
          points: [
            { x: BOARD_LEFT - toothDepth, y: prevRowY },
            { x: startX, y: rowY }, // Sharpest point where peg should be
            { x: BOARD_LEFT - toothDepth, y: nextRowY }
          ],
          row: row
        });
        
        // Right tooth - peak at the position where a peg would be
        teeth.push({
          points: [
            { x: BOARD_RIGHT + toothDepth, y: prevRowY },
            { x: startX + totalWidth, y: rowY }, // Sharpest point where peg should be
            { x: BOARD_RIGHT + toothDepth, y: nextRowY }
          ],
          row: row
        });
      } else {
        // Even rows (8 pegs)
        for (let col = 0; col < numPegs; col++) {
          const x = startX + col * PEG_SPACING_X;
          const y = rowY;
          
          pegs.push({
            x: x,
            y: y,
            lastHit: 0
          });
          
          if (row === NUM_ROWS - 1) {
            lastRowPegPositions.push(x);
          }
        }
      }
    }
  }

  function updateLegend(board) {
    const prizes = PRIZE_CONFIG[board].prizes;
    const legendContent = document.getElementById('legendContent');
    
    legendContent.innerHTML = prizes.map((prize, index) => `
      <div class="prize-item" style="border-left-color: ${prize.color}">
        <div class="prize-symbol">${prize.symbol}</div>
        <div class="prize-name">${prize.name}</div>
      </div>
    `).join('');
  }

  function drawBoard() {
    if (!needsRedraw && !currentPuck && particles.length === 0) return;
    
    ctx.fillStyle = '#F5E6D3';
    ctx.fillRect(0, 0, W, H);
    
    drawTrianglePattern();
    drawTeeth();
    
    pegs.forEach(peg => {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.beginPath();
      ctx.arc(peg.x + 1, peg.y + 1, PEG_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#D4A76A';
      ctx.beginPath();
      ctx.arc(peg.x, peg.y, PEG_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#E8C9A0';
      ctx.beginPath();
      ctx.arc(peg.x - 2, peg.y - 2, PEG_RADIUS * 0.4, 0, Math.PI * 2);
      ctx.fill();
    });
    
    drawPrizeSlots();
    drawParticles();
    
    if (currentPuck) {
      drawPuck(currentPuck.x, currentPuck.y);
    }
    
    needsRedraw = false;
  }

  function requestRedraw() {
    needsRedraw = true;
    drawBoard();
    needsRedraw = false;
  }

  function drawTeeth() {
    ctx.fillStyle = '#D4A76A';
    ctx.strokeStyle = '#B8956A';
    ctx.lineWidth = 2;
    
    teeth.forEach(tooth => {
      ctx.beginPath();
      ctx.moveTo(tooth.points[0].x, tooth.points[0].y);
      ctx.lineTo(tooth.points[1].x, tooth.points[1].y);
      ctx.lineTo(tooth.points[2].x, tooth.points[2].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    });
  }

  function drawTrianglePattern() {
    ctx.strokeStyle = 'rgba(180, 150, 120, 0.3)';
    ctx.lineWidth = 1;
    
    const triangleSize = 30;
    const rows = Math.ceil(H / (triangleSize * 0.866)) + 1;
    const cols = Math.ceil(W / triangleSize) + 1;
    
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const x = col * triangleSize + (row % 2 === 0 ? 0 : triangleSize / 2);
        const y = row * triangleSize * 0.866;
        
        ctx.beginPath();
        if ((row + col) % 2 === 0) {
          ctx.moveTo(x, y);
          ctx.lineTo(x + triangleSize, y);
          ctx.lineTo(x + triangleSize / 2, y + triangleSize * 0.866);
        } else {
          ctx.moveTo(x, y + triangleSize * 0.866);
          ctx.lineTo(x + triangleSize, y + triangleSize * 0.866);
          ctx.lineTo(x + triangleSize / 2, y);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }
  }

  function drawPrizeSlots() {
    const prizes = getCurrentPrizes();
    const slotCount = prizes.length;
    const slotHeight = H * 0.15;
    const bottomY = H - slotHeight;
    
    const slotWidth = W / slotCount;
    
    prizes.forEach((prize, index) => {
      const leftX = index * slotWidth;
      const rightX = (index + 1) * slotWidth;
      
      ctx.fillStyle = prize.color;
      ctx.beginPath();
      ctx.moveTo(leftX, bottomY);
      ctx.lineTo(rightX, bottomY);
      ctx.lineTo(rightX, H);
      ctx.lineTo(leftX, H);
      ctx.closePath();
      ctx.fill();
      
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 4;
      ctx.stroke();
      
      ctx.fillStyle = '#FFFFFF';
      ctx.font = `bold ${Math.min(48, slotWidth * 0.4)}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(prize.symbol, leftX + slotWidth / 2, bottomY + slotHeight * 0.5);
    });
    
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(0, bottomY);
    ctx.lineTo(W, bottomY);
    ctx.stroke();
  }

  function drawPuck(x, y) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.arc(x + 3, y + 3, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#FF3333';
    ctx.beginPath();
    ctx.arc(x, y, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineWidth = 4;
    ctx.stroke();
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.beginPath();
    ctx.arc(x - 8, y - 8, PUCK_RADIUS * 0.3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 16px Montserrat';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('USL', x, y);
  }

  function drawPuckInHolder() {
    holderCtx.clearRect(0, 0, 120, 120);
    
    if (gameState.pucksRemaining > 0 && !currentPuck) {
      const centerX = 60;
      const centerY = 60;
      
      if (gameState.pucksRemaining > 0) {
        holderCanvas.classList.add('has-pucks');
      } else {
        holderCanvas.classList.remove('has-pucks');
      }
      
      holderCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      holderCtx.beginPath();
      holderCtx.arc(centerX + 2, centerY + 2, 30, 0, Math.PI * 2);
      holderCtx.fill();
      
      holderCtx.fillStyle = '#FF3333';
      holderCtx.beginPath();
      holderCtx.arc(centerX, centerY, 30, 0, Math.PI * 2);
      holderCtx.fill();
      
      holderCtx.strokeStyle = '#FFFFFF';
      holderCtx.lineWidth = 3;
      holderCtx.stroke();
      
      holderCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      holderCtx.beginPath();
      holderCtx.arc(centerX - 6, centerY - 6, 8, 0, Math.PI * 2);
      holderCtx.fill();
      
      holderCtx.fillStyle = '#FFFFFF';
      holderCtx.font = 'bold 14px Montserrat';
      holderCtx.textAlign = 'center';
      holderCtx.textBaseline = 'middle';
      holderCtx.fillText('USL', centerX, centerY);
    } else {
      holderCanvas.classList.remove('has-pucks');
    }
  }

  function drawParticles() {
    particles = particles.filter(p => {
      p.life--;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.2;
      
      if (p.life <= 0) return false;
      
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      
      return true;
    });
    
    ctx.globalAlpha = 1;
  }

  function updatePhysics(timestamp) {
    if (!currentPuck || !gameActive) return;
    
    const deltaTime = Math.min(16, timestamp - lastTime) / 16;
    lastTime = timestamp;
    
    currentPuck.vy += 0.5 * deltaTime;
    currentPuck.x += currentPuck.vx * deltaTime;
    currentPuck.y += currentPuck.vy * deltaTime;
    
    currentPuck.vx *= 0.995;
    currentPuck.vy *= 0.996;
    
    // Wall boundaries at play area edges (with small margin for puck radius)
    const wallMargin = PUCK_RADIUS + 5;
    
    if (currentPuck.x < BOARD_LEFT + wallMargin) {
      currentPuck.x = BOARD_LEFT + wallMargin;
      currentPuck.vx = Math.abs(currentPuck.vx) * 0.7;
    } else if (currentPuck.x > BOARD_RIGHT - wallMargin) {
      currentPuck.x = BOARD_RIGHT - wallMargin;
      currentPuck.vx = -Math.abs(currentPuck.vx) * 0.7;
    }
    
    // Teeth collision detection
    const currentTime = Date.now();
    
    teeth.forEach(tooth => {
      // Check if puck is near this tooth
      const toothCenterX = (tooth.points[0].x + tooth.points[1].x + tooth.points[2].x) / 3;
      const toothCenterY = (tooth.points[0].y + tooth.points[1].y + tooth.points[2].y) / 3;
      const distanceToTooth = Math.sqrt(
        (currentPuck.x - toothCenterX) ** 2 + (currentPuck.y - toothCenterY) ** 2
      );
      
      if (distanceToTooth < PUCK_RADIUS * 3) {
        // More detailed collision detection with triangle
        for (let i = 0; i < tooth.points.length; i++) {
          const p1 = tooth.points[i];
          const p2 = tooth.points[(i + 1) % tooth.points.length];
          
          // Calculate distance from puck to line segment
          const lineLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
          const t = Math.max(0, Math.min(1, 
            ((currentPuck.x - p1.x) * (p2.x - p1.x) + 
             (currentPuck.y - p1.y) * (p2.y - p1.y)) / (lineLength * lineLength)
          ));
          
          const closestX = p1.x + t * (p2.x - p1.x);
          const closestY = p1.y + t * (p2.y - p1.y);
          
          const distance = Math.sqrt(
            (currentPuck.x - closestX) ** 2 + (currentPuck.y - closestY) ** 2
          );
          
          if (distance < PUCK_RADIUS + 2) {
            // Collision detected with tooth edge
            const nx = (currentPuck.x - closestX) / distance;
            const ny = (currentPuck.y - closestY) / distance;
            
            const overlap = PUCK_RADIUS + 2 - distance;
            currentPuck.x += nx * overlap;
            currentPuck.y += ny * overlap;
            
            const dotProduct = currentPuck.vx * nx + currentPuck.vy * ny;
            currentPuck.vx -= 1.6 * dotProduct * nx;
            currentPuck.vy -= 1.6 * dotProduct * ny;
            
            const speed = Math.sqrt(currentPuck.vx ** 2 + currentPuck.vy ** 2);
            const intensity = Math.min(1, speed / 10);
            audioSystem.playPegHit(intensity);
            
            break;
          }
        }
      }
    });
    
    // Peg collision detection
    pegs.forEach(peg => {
      if (currentTime - peg.lastHit < 100) return;
      
      const dx = currentPuck.x - peg.x;
      const dy = currentPuck.y - peg.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDistance = PUCK_RADIUS + PEG_RADIUS + 2;
      
      if (distance < minDistance) {
        peg.lastHit = currentTime;
        
        const speed = Math.sqrt(currentPuck.vx ** 2 + currentPuck.vy ** 2);
        const intensity = Math.min(1, speed / 10);
        audioSystem.playPegHit(intensity);
        
        const nx = dx / distance;
        const ny = dy / distance;
        
        const overlap = minDistance - distance;
        currentPuck.x += nx * overlap;
        currentPuck.y += ny * overlap;
        
        const dotProduct = currentPuck.vx * nx + currentPuck.vy * ny;
        currentPuck.vx -= 1.6 * dotProduct * nx;
        currentPuck.vy -= 1.6 * dotProduct * ny;
        
        currentPuck.vx += (Math.random() - 0.5) * 1.2;
        currentPuck.vy += (Math.random() - 0.5) * 0.6;
      }
    });
    
    if (currentPuck.y + PUCK_RADIUS > H - H * 0.15) {
      handlePuckLanding();
      return;
    }
    
    drawBoard();
    animationId = requestAnimationFrame(updatePhysics);
  }

  async function handlePuckLanding() {
    const prizes = getCurrentPrizes();
    const slotCount = prizes.length;
    const slotWidth = W / slotCount;
    
    let slotIndex = Math.floor(currentPuck.x / slotWidth);
    slotIndex = Math.max(0, Math.min(prizes.length - 1, slotIndex));
    
    const prize = prizes[slotIndex];
    
    const slotCenterX = (slotIndex * slotWidth) + (slotWidth / 2);
    currentPuck.x = slotCenterX;
    currentPuck.y = H - (H * 0.15) + (PUCK_RADIUS / 2);
    
    audioSystem.playWin();
    
    const totalPucks = gameState.results.length + 1;
    const currentBoardWins = gameState.results.filter(r => r.board === gameState.currentBoard).length + 1;
    const statsText = `Win ${currentBoardWins} of ${totalPucks} pucks`;
    
    document.getElementById('winSymbol').textContent = prize.symbol;
    document.getElementById('winPrize').textContent = prize.name;
    document.getElementById('winStats').textContent = statsText;
    document.getElementById('winAnnouncement').classList.add('show');
    
    for (let i = 0; i < 80; i++) {
      const angle = (Math.PI * 2 * i) / 80;
      const speed = Math.random() * 8 + 4;
      
      particles.push({
        x: slotCenterX,
        y: H - H * 0.075,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 4,
        life: 50,
        maxLife: 50,
        size: 3,
        color: prize.color
      });
    }
    
    if (!gameState.results) gameState.results = [];
    gameState.results.push({
      board: gameState.currentBoard,
      slot: slotIndex,
      prize: {
        symbol: prize.symbol,
        name: prize.name
      },
      timestamp: new Date().toISOString()
    });
    
    gameState.pucksRemaining--;
    gameState.lastUpdated = new Date().toISOString();
    
    await saveState();
    
    if (gameState.boardConfig === 'BOTH' && gameState.currentBoard === 'A' && 
        gameState.pucksRemaining <= gameState.puckCountB) {
      gameState.currentBoard = 'B';
      updateLegend('B');
      initPegs();
      showTemporaryMessage('Switching to Board B!', 2000);
    }
    
    if (gameState.pucksRemaining <= 0) {
      gameActive = false;
      setTimeout(() => {
        document.getElementById('gameOverScreen').style.display = 'block';
      }, 2000);
    }
    
    currentPuck = null;
    
    setTimeout(() => {
      canDragPuck = true;
    }, 500);
    
    updateDisplay();
    drawPuckInHolder();
    
    cancelAnimationFrame(animationId);
    drawBoard();
  }

  function updateDisplay() {
    document.getElementById('puckCounter').textContent = gameState.pucksRemaining;
    document.getElementById('currentBoard').textContent = gameState.currentBoard;
  }

  async function saveState() {
    try {
      console.log('Saving game state...');
      await updateGameBin(binId, gameState);
      console.log('Game state saved successfully');
    } catch (error) {
      console.error('Failed to save game state:', error);
      showTemporaryMessage('Failed to save progress', 2000);
    }
  }

  function getCanvasCoords(e, targetCanvas) {
    const rect = targetCanvas.getBoundingClientRect();
    const scaleX = targetCanvas.width / rect.width;
    const scaleY = targetCanvas.height / rect.height;
    
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  }

  function handleHolderMouseDown(e) {
    if (!gameActive || currentPuck || gameState.pucksRemaining === 0 || !canDragPuck) return;
    
    audioSystem.init();
    
    const coords = getCanvasCoords(e, holderCanvas);
    const distance = Math.sqrt((coords.x - 60) ** 2 + (coords.y - 60) ** 2);
    
    if (distance < 35) {
      isDragging = true;
      canDragPuck = false;
      
      holderCanvas.style.transform = 'scale(0.9)';
      
      audioSystem.playDropSound();
      
      currentPuck = {
        x: W / 2,
        y: 50,
        vx: 0,
        vy: 0
      };
      
      drawPuckInHolder();
      drawBoard();
    }
  }

  function handleCanvasMove(e) {
    if (!isDragging || !currentPuck) return;
    
    const coords = getCanvasCoords(e, canvas);
    currentPuck.x = Math.max(PUCK_RADIUS, Math.min(W - PUCK_RADIUS, coords.x));
    currentPuck.y = Math.max(PUCK_RADIUS, Math.min(H - PUCK_RADIUS, coords.y));
    drawBoard();
  }

  function handleRelease(e) {
    if (!isDragging || !currentPuck) return;
    
    isDragging = false;
    holderCanvas.style.transform = 'scale(1)';
    
    const topThreshold = H * 0.10;
    
    if (currentPuck.y > topThreshold) {
      currentPuck = null;
      canDragPuck = true;
      drawPuckInHolder();
      drawBoard();
      return;
    }
    
    const releaseVariation = (currentPuck.x - W/2) / (W/2) * 0.8;
    currentPuck.vx = releaseVariation;
    currentPuck.vy = 0.5;
    
    lastTime = performance.now();
    animationId = requestAnimationFrame(updatePhysics);
    saveState();
  }

  holderCanvas.addEventListener('mousedown', handleHolderMouseDown);
  holderCanvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    handleHolderMouseDown(e);
  });

  canvas.addEventListener('mousemove', handleCanvasMove);
  canvas.addEventListener('mouseup', handleRelease);
  canvas.addEventListener('mouseleave', handleRelease);
  
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    handleCanvasMove(e);
  });
  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    handleRelease(e);
  });

  initPegs();
  updateDisplay();
  drawBoard();
  drawPuckInHolder();
}
</script>
</body>
</html>
