<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>U.S. LawShield PLINKO ‚Äì JSONBin.io Real-Time</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body {
    font-family: 'Montserrat', sans-serif;
    background: linear-gradient(135deg, #002244 0%, #003366 50%, #002244 100%);
    min-height: 100vh;
    color: white;
    overflow-x: hidden;
  }

  .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
    display: grid;
    grid-template-columns: 1fr 400px;
    gap: 30px;
  }

  .header {
    grid-column: 1 / -1;
    text-align: center;
    padding: 20px;
    background: linear-gradient(180deg, rgba(0, 34, 68, 0.95) 0%, rgba(0, 34, 68, 0.8) 100%);
    border-bottom: 4px solid #69BE28;
    border-radius: 15px;
    margin-bottom: 20px;
  }

  .title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 4em;
    letter-spacing: 6px;
    text-shadow: 0 0 30px #69BE28, 3px 3px 0 #000;
    color: white;
    margin-bottom: 8px;
  }

  .subtitle {
    font-size: 1.4em;
    letter-spacing: 3px;
    color: #69BE28;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    font-weight: 600;
  }

  .game-section {
    background: rgba(0, 25, 51, 0.8);
    border-radius: 20px;
    padding: 20px;
    border: 3px solid #69BE28;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
  }

  .canvas-wrapper {
    position: relative;
    border-radius: 15px;
    overflow: hidden;
    box-shadow: 0 0 60px rgba(105, 190, 40, 0.4);
    border: 6px solid #002244;
    background: #001933;
    margin-bottom: 20px;
  }

  #plinkoCanvas {
    display: block;
    background: #001933;
    width: 100%;
  }

  .drop-zone {
    background: linear-gradient(135deg, #69BE28 0%, #4A8A1F 100%);
    padding: 15px;
    border-radius: 12px;
    font-size: 20px;
    font-weight: 800;
    box-shadow: 0 8px 25px rgba(105, 190, 40, 0.6);
    border: 3px solid #002244;
    color: #002244;
    text-align: center;
    position: relative;
  }

  .prompt {
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: #002244;
    padding: 5px 15px;
    border-radius: 12px;
    font-size: 12px;
    white-space: nowrap;
    font-weight: 600;
    border: 2px solid #69BE28;
    color: #69BE28;
  }

  .control-section {
    background: rgba(0, 25, 51, 0.8);
    border-radius: 20px;
    padding: 25px;
    border: 3px solid #69BE28;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .setup-panel {
    background: rgba(0, 34, 68, 0.9);
    padding: 20px;
    border-radius: 15px;
    border: 2px solid #69BE28;
  }

  .panel-title {
    color: #69BE28;
    font-size: 24px;
    margin-bottom: 15px;
    text-align: center;
    font-family: 'Bebas Neue', sans-serif;
    letter-spacing: 2px;
  }

  .form-group {
    margin-bottom: 15px;
  }

  label {
    display: block;
    color: #A5ACAF;
    margin-bottom: 8px;
    font-weight: 600;
    font-size: 14px;
  }

  input[type="text"], select {
    width: 100%;
    padding: 12px;
    border: 2px solid #69BE28;
    border-radius: 8px;
    background: #001933;
    color: white;
    font-family: 'Montserrat', sans-serif;
    font-size: 14px;
  }

  .board-selection {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
  }

  .board-option {
    flex: 1;
    text-align: center;
    padding: 12px;
    background: #001933;
    border: 2px solid #69BE28;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    color: #A5ACAF;
    font-weight: 600;
  }

  .board-option.selected {
    background: #69BE28;
    color: #002244;
    border-color: #002244;
  }

  .btn {
    background: linear-gradient(135deg, #69BE28 0%, #4A8A1F 100%);
    color: #002244;
    padding: 15px 25px;
    border: none;
    border-radius: 50px;
    font-size: 16px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    border: 3px solid #002244;
    font-family: 'Montserrat', sans-serif;
    width: 100%;
  }

  .btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(105, 190, 40, 0.8);
  }

  .btn-cta {
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    font-size: 18px;
    padding: 18px;
  }

  .game-info {
    background: rgba(0, 34, 68, 0.9);
    padding: 20px;
    border-radius: 15px;
    border: 2px solid #69BE28;
  }

  .info-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 12px;
    padding: 8px 0;
    border-bottom: 1px solid rgba(105, 190, 40, 0.3);
  }

  .info-label {
    color: #A5ACAF;
    font-weight: 600;
  }

  .info-value {
    color: #69BE28;
    font-weight: 800;
  }

  .prize-legend {
    background: rgba(0, 34, 68, 0.9);
    padding: 20px;
    border-radius: 15px;
    border: 2px solid #69BE28;
    max-height: 300px;
    overflow-y: auto;
  }

  .legend-title {
    color: #69BE28;
    font-size: 20px;
    margin-bottom: 15px;
    text-align: center;
    font-family: 'Bebas Neue', sans-serif;
    letter-spacing: 2px;
  }

  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    padding: 8px;
    background: rgba(0, 25, 51, 0.7);
    border-radius: 8px;
  }

  .legend-symbol {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 800;
    margin-right: 12px;
    flex-shrink: 0;
    border: 2px solid white;
  }

  .legend-text {
    color: white;
    font-size: 12px;
    font-weight: 600;
    line-height: 1.3;
  }

  .current-board {
    position: absolute;
    top: 15px;
    left: 15px;
    background: rgba(0, 34, 68, 0.9);
    padding: 10px 20px;
    border-radius: 20px;
    border: 2px solid #69BE28;
    color: #69BE28;
    font-weight: 800;
    z-index: 10;
  }

  .puck-counter {
    position: absolute;
    top: 15px;
    right: 15px;
    background: rgba(0, 34, 68, 0.9);
    padding: 10px 20px;
    border-radius: 20px;
    border: 2px solid #69BE28;
    color: #69BE28;
    font-weight: 800;
    z-index: 10;
  }

  .connection-status {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 34, 68, 0.9);
    padding: 8px 16px;
    border-radius: 20px;
    border: 2px solid #69BE28;
    color: #69BE28;
    font-weight: 600;
    font-size: 12px;
    z-index: 10;
  }

  .bigwin {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-size: 6em;
    color: #FFD700;
    text-shadow: 0 0 40px #FFD700, 0 0 80px #FFA500;
    z-index: 9999;
    pointer-events: none;
    animation: win 2s forwards;
    font-family: 'Bebas Neue', sans-serif;
    letter-spacing: 6px;
    text-align: center;
  }

  @keyframes win {
    0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }

  .admin-panel {
    grid-column: 1 / -1;
    background: rgba(0, 25, 51, 0.9);
    border-radius: 15px;
    padding: 25px;
    border: 3px solid #69BE28;
    margin-top: 20px;
  }

  .admin-controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
  }

  .admin-btn {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
    color: white;
    padding: 12px 20px;
    border: none;
    border-radius: 8px;
    font-weight: 800;
    cursor: pointer;
    transition: all 0.3s;
  }

  .admin-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
  }

  .prize-display {
    background: rgba(0, 34, 68, 0.9);
    padding: 20px;
    border-radius: 15px;
    border: 2px solid #69BE28;
    margin-top: 20px;
  }

  .prize-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 10px;
  }

  .prize-item {
    background: rgba(0, 25, 51, 0.7);
    padding: 15px;
    border-radius: 10px;
    border: 2px solid #69BE28;
    text-align: center;
  }

  .prize-symbol {
    font-size: 2em;
    margin-bottom: 8px;
  }

  .prize-name {
    color: #69BE28;
    font-weight: 800;
    font-size: 14px;
    line-height: 1.3;
  }

  .board-b {
    background: linear-gradient(135deg, #8B4513 0%, #D2691E 100%);
    border-color: #FFD700;
  }

  .board-b .legend-symbol {
    border-color: #FFD700;
  }

  .mode-selector {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
  }

  .mode-btn {
    flex: 1;
    padding: 12px;
    background: #001933;
    border: 2px solid #69BE28;
    border-radius: 8px;
    color: #A5ACAF;
    font-weight: 600;
    cursor: pointer;
    text-align: center;
    transition: all 0.3s;
  }

  .mode-btn.active {
    background: #69BE28;
    color: #002244;
    border-color: #002244;
  }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1 class="title">U.S. LAWSHIELD PLINKO</h1>
    <p class="subtitle">LEGAL DEFENSE FOR SELF DEFENSE¬Æ</p>
  </div>

  <div class="mode-selector">
    <div class="mode-btn active" data-mode="player">üéÆ PLAYER VIEW</div>
    <div class="mode-btn" data-mode="admin">‚öôÔ∏è ADMIN VIEW</div>
  </div>

  <div class="game-section">
    <div class="canvas-wrapper">
      <div class="current-board" id="currentBoard">BOARD A</div>
      <div class="puck-counter">PUCKS: <span id="puckCounter">0</span></div>
      <div class="connection-status" id="connectionStatus">üî¥ OFFLINE</div>
      <canvas id="plinkoCanvas" width="800" height="1000"></canvas>
    </div>
    <div class="drop-zone">
      DROP ZONE
      <div class="prompt">Hover puck ‚Üí Click & hold ‚Üí Position ‚Üí Release to drop!</div>
    </div>
  </div>

  <div class="control-section">
    <div class="setup-panel" id="playerSetup">
      <h3 class="panel-title">PLAYER SETUP</h3>
      <div class="form-group">
        <label for="playerName">Player Name:</label>
        <input type="text" id="playerName" placeholder="Enter player name">
      </div>
      <div class="form-group">
        <label>Select Board(s):</label>
        <div class="board-selection">
          <div class="board-option" data-board="A">Board A</div>
          <div class="board-option" data-board="B">Board B</div>
          <div class="board-option" data-board="BOTH">Both</div>
        </div>
      </div>
      <div class="form-group">
        <label for="puckCount">Number of Pucks:</label>
        <select id="puckCount">
          <option value="1">1 Puck</option>
          <option value="2">2 Pucks</option>
          <option value="3">3 Pucks</option>
          <option value="5">5 Pucks</option>
        </select>
      </div>
      <button class="btn btn-cta" id="startGame">START GAME</button>
    </div>

    <div class="setup-panel" id="adminSetup" style="display: none;">
      <h3 class="panel-title">ADMIN SETUP</h3>
      <div class="form-group">
        <label for="gameIdInput">Game ID to Monitor:</label>
        <input type="text" id="gameIdInput" placeholder="Enter Game ID">
      </div>
      <button class="btn btn-cta" id="connectToGame">CONNECT TO GAME</button>
    </div>

    <div class="game-info">
      <h3 class="panel-title">GAME INFO</h3>
      <div class="info-item">
        <span class="info-label">Game ID:</span>
        <span class="info-value" id="gameId">-</span>
      </div>
      <div class="info-item">
        <span class="info-label">Player:</span>
        <span class="info-value" id="playerDisplay">-</span>
      </div>
      <div class="info-item">
        <span class="info-label">Pucks Remaining:</span>
        <span class="info-value" id="pucksRemaining">0</span>
      </div>
      <div class="info-item">
        <span class="info-label">Total Won:</span>
        <span class="info-value" id="totalWon">0 prizes</span>
      </div>
    </div>

    <div class="prize-legend" id="legendA">
      <h3 class="legend-title">BOARD A PRIZES</h3>
      <!-- Legend items will be populated by JavaScript -->
    </div>

    <div class="prize-legend board-b" id="legendB" style="display: none;">
      <h3 class="legend-title">BOARD B PRIZES</h3>
      <!-- Legend items will be populated by JavaScript -->
    </div>
  </div>

  <div class="admin-panel">
    <h3 class="panel-title">ADMIN CONTROLS</h3>
    <div class="admin-controls">
      <button class="admin-btn" id="resetGame">Reset Game</button>
      <button class="admin-btn" id="addPuck">Add Puck</button>
      <button class="admin-btn" id="manualPrize">Add Manual Prize</button>
      <button class="admin-btn" id="switchBoard">Switch Board</button>
      <button class="admin-btn" id="copyGameLink">Copy Game Link</button>
    </div>
    
    <div class="prize-display">
      <h3 class="panel-title">PRIZES WON</h3>
      <div class="prize-list" id="wonPrizes">
        <!-- Won prizes will appear here -->
      </div>
    </div>
  </div>
</div>

<script>
// ==================== JSONBIN.IO CONFIGURATION ====================
const JSONBIN_CONFIG = {
  MASTER_KEY: '$2a$10$NckuWO.y9g8.amyZZWkc8.lKIMS.AVSCyN1qT9/0d5EtRjuV9lmS2',
  ACCESS_KEY: '$2a$10$g6RfQ66H6XQyYy3D848Cfurvs0dXgVt92aV0Rr0UqchZrBZwr7Vpy',
  BASE_URL: 'https://api.jsonbin.io/v3/b',
  HEADERS: {
    'Content-Type': 'application/json',
    'X-Master-Key': '$2a$10$NckuWO.y9g8.amyZZWkc8.lKIMS.AVSCyN1qT9/0d5EtRjuV9lmS2'
  }
};

// ==================== GAME STATE ====================
const gameState = {
  gameId: null,
  playerName: '',
  boardType: 'A',
  pucksTotal: 1,
  pucksUsed: 0,
  pucksRemaining: 0,
  currentBoard: 'A',
  prizesWon: [],
  isActive: false,
  currentPuck: null,
  isAdmin: false,
  connected: false,
  binId: null,
  lastUpdated: 0,
  boards: {
    A: {
      name: "Board A",
      color: '#69BE28',
      prizes: [
        { symbol: 'üéÅ', name: '$25 Gift Card', color: '#667eea' },
        { symbol: '‚è∞', name: '1 Hour Campaign of Your Choice', color: '#f093fb' },
        { symbol: 'üë•', name: 'Shadow an Agent for 1 Hour', color: '#4facfe' },
        { symbol: 'üö™', name: 'Leave 15min Early / Come in 15min Late', color: '#ff6b6b' },
        { symbol: '‚òï', name: 'Extra 15 Minute Break', color: '#f6d365' },
        { symbol: 'üìä', name: 'Replace QA Score with Call of Your Choice', color: '#4facfe' },
        { symbol: 'üíº', name: 'Coffee with Leadership', color: '#f093fb' },
        { symbol: '‚è∞', name: '1 Hour Campaign of Your Choice', color: '#f093fb' },
        { symbol: 'üéÅ', name: '$25 Gift Card', color: '#667eea' }
      ]
    },
    B: {
      name: "Board B",
      color: '#FFD700',
      prizes: [
        { symbol: 'üïë', name: '2 Hours Campaign of Your Choice', color: '#9b59b6' },
        { symbol: 'üí∞', name: '$50 Gift Card', color: '#e74c3c' },
        { symbol: '‚è±Ô∏è', name: 'Leave 30 Minutes Early', color: '#3498db' },
        { symbol: 'üíØ', name: 'Replace Lowest QA Score with 100', color: '#2ecc71' },
        { symbol: 'üïì', name: '4 Hours Campaign of Your Choice', color: '#f1c40f' },
        { symbol: 'üçΩÔ∏è', name: 'Lunch on Leadership', color: '#e67e22' },
        { symbol: 'üé¥', name: 'Wild Card', color: '#1abc9c' },
        { symbol: 'üí∞', name: '$50 Gift Card', color: '#e74c3c' },
        { symbol: 'üïë', name: '2 Hours Campaign of Your Choice', color: '#9b59b6' }
      ]
    }
  }
};

// ==================== JSONBIN.IO REAL-TIME SYNC ====================
let syncInterval = null;
let isConnected = false;

async function createGameBin(gameState) {
  try {
    const response = await fetch(JSONBIN_CONFIG.BASE_URL, {
      method: 'POST',
      headers: JSONBIN_CONFIG.HEADERS,
      body: JSON.stringify({
        ...gameState,
        created: Date.now(),
        version: 1
      })
    });
    
    const data = await response.json();
    if (data.metadata && data.metadata.id) {
      return data.metadata.id;
    }
    throw new Error('Failed to create bin');
  } catch (error) {
    console.error('Error creating game bin:', error);
    throw error;
  }
}

async function updateGameBin(binId, gameState) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}`, {
      method: 'PUT',
      headers: JSONBIN_CONFIG.HEADERS,
      body: JSON.stringify({
        ...gameState,
        lastUpdated: Date.now()
      })
    });
    
    const data = await response.json();
    return data.metadata && data.metadata.id;
  } catch (error) {
    console.error('Error updating game bin:', error);
    return false;
  }
}

async function readGameBin(binId) {
  try {
    const response = await fetch(`${JSONBIN_CONFIG.BASE_URL}/${binId}/latest`, {
      headers: {
        'X-Master-Key': JSONBIN_CONFIG.HEADERS['X-Master-Key']
      }
    });
    
    if (!response.ok) throw new Error('Failed to read bin');
    
    const data = await response.json();
    return data.record;
  } catch (error) {
    console.error('Error reading game bin:', error);
    return null;
  }
}

function startSyncInterval(binId) {
  if (syncInterval) clearInterval(syncInterval);
  
  syncInterval = setInterval(async () => {
    if (!binId) return;
    
    const remoteState = await readGameBin(binId);
    if (remoteState && remoteState.lastUpdated > gameState.lastUpdated) {
      // Don't override if we have local changes that are newer
      if (gameState.lastUpdated && gameState.lastUpdated > remoteState.lastUpdated) {
        return;
      }
      
      // Update from remote state
      Object.keys(remoteState).forEach(key => {
        if (key !== 'currentPuck' || !gameState.currentPuck) {
          gameState[key] = remoteState[key];
        }
      });
      
      updateGameDisplay();
      updateBoardDisplay();
      drawBoard();
      
      // Update connection status
      isConnected = true;
      updateConnectionStatus();
    }
  }, 2000); // Sync every 2 seconds to stay within rate limits
}

function stopSyncInterval() {
  if (syncInterval) {
    clearInterval(syncInterval);
    syncInterval = null;
  }
}

function updateConnectionStatus() {
  const statusElement = document.getElementById('connectionStatus');
  if (isConnected) {
    statusElement.textContent = 'üü¢ SYNCED';
    statusElement.style.borderColor = '#69BE28';
  } else {
    statusElement.textContent = 'üî¥ OFFLINE';
    statusElement.style.borderColor = '#ff6b6b';
  }
}

async function saveGameStateToCloud() {
  if (!gameState.binId) return false;
  
  gameState.lastUpdated = Date.now();
  const success = await updateGameBin(gameState.binId, gameState);
  isConnected = success;
  updateConnectionStatus();
  return success;
}

async function loadGameStateFromCloud(binId) {
  const remoteState = await readGameBin(binId);
  if (remoteState) {
    Object.assign(gameState, remoteState);
    gameState.binId = binId;
    isConnected = true;
    updateConnectionStatus();
    updateGameDisplay();
    updateBoardDisplay();
    drawBoard();
    startSyncInterval(binId);
    return true;
  }
  return false;
}

// ==================== PLINKO PHYSICS ====================
const canvas = document.getElementById('plinkoCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const DROP_ZONE_HEIGHT = 120;
const PUCK_RADIUS = 18;
const PEG_RADIUS = 6;
const NUM_ROWS = 16;
const NUM_SLOTS = 9;

let pegs = [];
let currentPuck = null;
let dragging = false;
let hoverPuck = { x: W/2, y: DROP_ZONE_HEIGHT/2 };
let animationId = null;
let particles = [];

// Initialize pegs
function initPegs() {
  pegs = [];
  const startY = DROP_ZONE_HEIGHT + 80;
  const rowHeight = (H - 200 - startY) / NUM_ROWS;
  const colSpacing = W / 8;
  
  for (let row = 0; row < NUM_ROWS; row++) {
    const numCols = row % 2 === 0 ? 9 : 8;
    const offset = row % 2 === 0 ? 0 : colSpacing / 2;
    
    for (let col = 0; col < numCols; col++) {
      pegs.push({
        x: offset + col * colSpacing,
        y: startY + row * rowHeight
      });
    }
  }
}

// Draw the board
function drawBoard() {
  // Clear canvas
  ctx.fillStyle = '#001933';
  ctx.fillRect(0, 0, W, H);
  
  // Draw drop zone
  const dropGradient = ctx.createLinearGradient(0, 0, 0, DROP_ZONE_HEIGHT);
  dropGradient.addColorStop(0, '#69BE28');
  dropGradient.addColorStop(1, '#4A8A1F');
  ctx.fillStyle = dropGradient;
  ctx.fillRect(0, 0, W, DROP_ZONE_HEIGHT);
  
  ctx.strokeStyle = '#002244';
  ctx.lineWidth = 4;
  ctx.strokeRect(0, 0, W, DROP_ZONE_HEIGHT);
  
  ctx.fillStyle = '#002244';
  ctx.font = 'bold 24px Montserrat';
  ctx.textAlign = 'center';
  ctx.fillText('DROP ZONE', W/2, DROP_ZONE_HEIGHT/2 + 8);
  
  // Draw pegs
  pegs.forEach(peg => {
    const pegGradient = ctx.createRadialGradient(
      peg.x - 3, peg.y - 3, 0, peg.x, peg.y, PEG_RADIUS
    );
    pegGradient.addColorStop(0, '#69BE28');
    pegGradient.addColorStop(1, '#4A8A1F');
    
    ctx.fillStyle = pegGradient;
    ctx.beginPath();
    ctx.arc(peg.x, peg.y, PEG_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowColor = '#69BE28';
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;
  });
  
  // Draw slots
  const currentBoard = gameState.boards[gameState.currentBoard];
  const slotHeight = 80;
  const slotWidth = W / NUM_SLOTS;
  
  currentBoard.prizes.forEach((prize, index) => {
    // Slot background
    ctx.fillStyle = prize.color;
    ctx.fillRect(index * slotWidth, H - slotHeight, slotWidth, slotHeight);
    
    // Slot border
    ctx.strokeStyle = currentBoard.color;
    ctx.lineWidth = 3;
    ctx.strokeRect(index * slotWidth, H - slotHeight, slotWidth, slotHeight);
    
    // Prize symbol (rotated)
    ctx.save();
    ctx.translate(index * slotWidth + slotWidth/2, H - slotHeight/2);
    ctx.rotate(-Math.PI/2);
    
    ctx.fillStyle = 'white';
    ctx.font = 'bold 20px Montserrat';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(prize.symbol, 0, 0);
    
    ctx.restore();
  });
  
  // Draw hover puck (if available and not dragging)
  if (gameState.pucksRemaining > 0 && !currentPuck && !dragging && !gameState.isAdmin) {
    drawPuck(hoverPuck.x, hoverPuck.y);
  }
  
  // Draw current puck
  if (currentPuck) {
    drawPuck(currentPuck.x, currentPuck.y, currentPuck.rotation);
  }
  
  // Draw particles
  particles.forEach((particle, index) => {
    particle.life--;
    if (particle.life <= 0) {
      particles.splice(index, 1);
      return;
    }
    
    ctx.globalAlpha = particle.life / 60;
    ctx.fillStyle = particle.color;
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

function drawPuck(x, y, rotation = 0) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);
  
  const puckGradient = ctx.createRadialGradient(-6, -6, 0, 0, 0, PUCK_RADIUS);
  puckGradient.addColorStop(0, '#69BE28');
  puckGradient.addColorStop(0.7, '#4A8A1F');
  puckGradient.addColorStop(1, '#002244');
  
  ctx.fillStyle = puckGradient;
  ctx.beginPath();
  ctx.arc(0, 0, PUCK_RADIUS, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = '#002244';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.fillStyle = '#002244';
  ctx.beginPath();
  ctx.arc(-6, -6, PUCK_RADIUS * 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = 'white';
  ctx.font = 'bold 14px Montserrat';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('USL', 0, 0);
  
  ctx.restore();
}

// Physics simulation
function updatePhysics() {
  if (!currentPuck) return;
  
  // Apply gravity
  currentPuck.vy += 0.5;
  
  // Update position
  currentPuck.x += currentPuck.vx;
  currentPuck.y += currentPuck.vy;
  
  // Update rotation based on velocity
  currentPuck.rotation += currentPuck.vx * 0.02;
  
  // Save puck position to cloud for real-time sync
  if (gameState.binId) {
    gameState.currentPuck = currentPuck;
    saveGameStateToCloud();
  }
  
  // Wall collisions
  if (currentPuck.x - PUCK_RADIUS < 0) {
    currentPuck.x = PUCK_RADIUS;
    currentPuck.vx = Math.abs(currentPuck.vx) * 0.8;
  } else if (currentPuck.x + PUCK_RADIUS > W) {
    currentPuck.x = W - PUCK_RADIUS;
    currentPuck.vx = -Math.abs(currentPuck.vx) * 0.8;
  }
  
  // Peg collisions
  pegs.forEach(peg => {
    const dx = currentPuck.x - peg.x;
    const dy = currentPuck.y - peg.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const minDistance = PUCK_RADIUS + PEG_RADIUS;
    
    if (distance < minDistance) {
      // Collision response
      const angle = Math.atan2(dy, dx);
      const targetX = peg.x + Math.cos(angle) * minDistance;
      const targetY = peg.y + Math.sin(angle) * minDistance;
      
      currentPuck.x = targetX;
      currentPuck.y = targetY;
      
      // Reflect velocity with energy loss
      const dot = currentPuck.vx * dx + currentPuck.vy * dy;
      currentPuck.vx -= 1.8 * dot * dx / (distance * distance);
      currentPuck.vy -= 1.8 * dot * dy / (distance * distance);
      
      // Add some randomness for authentic Plinko behavior
      currentPuck.vx += (Math.random() - 0.5) * 2;
      currentPuck.vy += (Math.random() - 0.5) * 2;
    }
  });
  
  // Check if puck reached bottom slots
  if (currentPuck.y + PUCK_RADIUS > H - 80) {
    const slotIndex = Math.floor(currentPuck.x / (W / NUM_SLOTS));
    const currentBoard = gameState.boards[gameState.currentBoard];
    const prize = currentBoard.prizes[slotIndex];
    
    // Award prize
    gameState.prizesWon.push({
      board: gameState.currentBoard,
      prize: prize.name,
      symbol: prize.symbol,
      timestamp: Date.now()
    });
    
    // Create celebration particles
    for (let i = 0; i < 30; i++) {
      particles.push({
        x: currentPuck.x,
        y: H - 40,
        vx: (Math.random() - 0.5) * 10,
        vy: -Math.random() * 15,
        life: 60,
        size: Math.random() * 4 + 2,
        color: prize.color
      });
    }
    
    // Show win animation for special prizes
    if (slotIndex === 4) { // Middle slot - biggest prize
      const winElement = document.createElement('div');
      winElement.className = 'bigwin';
      winElement.textContent = 'BIG PRIZE!';
      document.body.appendChild(winElement);
      setTimeout(() => winElement.remove(), 2000);
    }
    
    // Update game state
    gameState.pucksUsed++;
    gameState.pucksRemaining--;
    gameState.currentPuck = null;
    currentPuck = null;
    
    // Check if should switch boards
    if (gameState.boardType === 'BOTH' && gameState.currentBoard === 'A') {
      gameState.currentBoard = 'B';
      updateBoardDisplay();
      initPegs();
    } else if (gameState.pucksRemaining === 0) {
      // Game over
      gameState.isActive = false;
    }
    
    // Save final state to cloud
    saveGameStateToCloud();
    updateGameDisplay();
    
    cancelAnimationFrame(animationId);
    drawBoard();
    return;
  }
  
  drawBoard();
  animationId = requestAnimationFrame(updatePhysics);
}

// ==================== GAME CONTROLS ====================
async function startGame() {
  const playerName = document.getElementById('playerName').value.trim();
  const puckCount = parseInt(document.getElementById('puckCount').value);
  const selectedBoard = document.querySelector('.board-option.selected').dataset.board;
  
  if (!playerName) {
    alert('Please enter a player name');
    return;
  }
  
  gameState.playerName = playerName;
  gameState.boardType = selectedBoard;
  gameState.pucksTotal = puckCount;
  gameState.pucksRemaining = puckCount;
  gameState.pucksUsed = 0;
  gameState.currentBoard = selectedBoard === 'B' ? 'B' : 'A';
  gameState.prizesWon = [];
  gameState.isActive = true;
  gameState.isAdmin = false;
  gameState.gameId = 'G' + Date.now().toString().slice(-6);
  gameState.lastUpdated = Date.now();
  
  try {
    // Create cloud storage
    gameState.binId = await createGameBin(gameState);
    isConnected = true;
    updateConnectionStatus();
    
    // Start synchronization
    startSyncInterval(gameState.binId);
  } catch (error) {
    console.error('Failed to create cloud game:', error);
    alert('Failed to create cloud game. Using local mode only.');
    isConnected = false;
    updateConnectionStatus();
  }
  
  // Update displays
  updateGameDisplay();
  updateBoardDisplay();
  
  // Initialize board
  initPegs();
  drawBoard();
  
  // Animate hover puck
  if (!gameState.isAdmin) {
    animateHoverPuck();
  }
}

function updateBoardDisplay() {
  document.getElementById('currentBoard').textContent = `BOARD ${gameState.currentBoard}`;
  
  // Show appropriate legend
  document.getElementById('legendA').style.display = 
    gameState.currentBoard === 'A' || gameState.boardType === 'BOTH' ? 'block' : 'none';
  document.getElementById('legendB').style.display = 
    gameState.currentBoard === 'B' ? 'block' : 'none';
}

function animateHoverPuck() {
  if (!gameState.isActive || currentPuck || gameState.pucksRemaining === 0 || gameState.isAdmin) return;
  
  hoverPuck.x = W/2 + Math.sin(Date.now() * 0.002) * (W/2 - PUCK_RADIUS - 50);
  drawBoard();
  requestAnimationFrame(animateHoverPuck);
}

function updateGameDisplay() {
  document.getElementById('gameId').textContent = gameState.gameId || '-';
  document.getElementById('playerDisplay').textContent = gameState.playerName || '-';
  document.getElementById('puckCounter').textContent = gameState.pucksRemaining;
  document.getElementById('pucksRemaining').textContent = gameState.pucksRemaining;
  document.getElementById('totalWon').textContent = `${gameState.prizesWon.length} prizes`;
  
  // Update won prizes display
  const wonPrizesElement = document.getElementById('wonPrizes');
  wonPrizesElement.innerHTML = '';
  
  gameState.prizesWon.forEach(prize => {
    const prizeElement = document.createElement('div');
    prizeElement.className = 'prize-item';
    prizeElement.innerHTML = `
      <div class="prize-symbol">${prize.symbol}</div>
      <div class="prize-name">${prize.prize}</div>
      <div style="font-size: 10px; color: #A5ACAF;">Board ${prize.board}</div>
    `;
    wonPrizesElement.appendChild(prizeElement);
  });
}

// ==================== EVENT HANDLERS ====================
canvas.addEventListener('mousemove', (e) => {
  if (gameState.isAdmin) return; // Admins can't interact with the board
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  if (dragging && currentPuck) {
    currentPuck.x = Math.max(PUCK_RADIUS, Math.min(W - PUCK_RADIUS, x));
    currentPuck.y = Math.max(PUCK_RADIUS, Math.min(DROP_ZONE_HEIGHT - PUCK_RADIUS, y));
    drawBoard();
  } else if (gameState.pucksRemaining > 0 && !currentPuck) {
    hoverPuck.x = x;
    hoverPuck.y = y;
  }
});

canvas.addEventListener('mousedown', (e) => {
  if (gameState.isAdmin || !gameState.isActive || currentPuck || gameState.pucksRemaining === 0) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Check if clicking near hover puck
  const distance = Math.sqrt(
    Math.pow(x - hoverPuck.x, 2) + Math.pow(y - hoverPuck.y, 2)
  );
  
  if (distance < PUCK_RADIUS * 1.5) {
    dragging = true;
    currentPuck = {
      x: x,
      y: y,
      vx: 0,
      vy: 0,
      rotation: 0
    };
    drawBoard();
  }
});

canvas.addEventListener('mouseup', () => {
  if (gameState.isAdmin) return;
  
  if (dragging && currentPuck) {
    dragging = false;
    
    // Add initial velocity based on drop position for more realistic physics
    const centerX = W / 2;
    currentPuck.vx = (currentPuck.x - centerX) * 0.5;
    currentPuck.vy = 2;
    
    animationId = requestAnimationFrame(updatePhysics);
  }
});

// Board selection
document.querySelectorAll('.board-option').forEach(option => {
  option.addEventListener('click', () => {
    document.querySelectorAll('.board-option').forEach(opt => opt.classList.remove('selected'));
    option.classList.add('selected');
  });
});

// Mode selection
document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    
    const mode = btn.dataset.mode;
    if (mode === 'player') {
      gameState.isAdmin = false;
      document.getElementById('playerSetup').style.display = 'block';
      document.getElementById('adminSetup').style.display = 'none';
      canvas.style.cursor = 'default';
    } else {
      gameState.isAdmin = true;
      document.getElementById('playerSetup').style.display = 'none';
      document.getElementById('adminSetup').style.display = 'block';
      canvas.style.cursor = 'default';
    }
  });
});

// Start game button
document.getElementById('startGame').addEventListener('click', startGame);

// Connect to game button
document.getElementById('connectToGame').addEventListener('click', async () => {
  const gameId = document.getElementById('gameIdInput').value.trim();
  if (!gameId) {
    alert('Please enter a Game ID');
    return;
  }
  
  gameState.isAdmin = true;
  gameState.gameId = gameId;
  const success = await loadGameStateFromCloud(gameId);
  if (success) {
    updateGameDisplay();
  } else {
    alert('Failed to connect to game. Check the Game ID.');
  }
});

// Admin controls
document.getElementById('resetGame').addEventListener('click', async () => {
  if (confirm('Reset the game? This will clear all progress.')) {
    gameState.isActive = false;
    currentPuck = null;
    gameState.currentPuck = null;
    gameState.prizesWon = [];
    gameState.pucksRemaining = gameState.pucksTotal;
    gameState.pucksUsed = 0;
    gameState.currentBoard = gameState.boardType === 'B' ? 'B' : 'A';
    updateGameDisplay();
    updateBoardDisplay();
    await saveGameStateToCloud();
    drawBoard();
  }
});

document.getElementById('addPuck').addEventListener('click', async () => {
  gameState.pucksRemaining++;
  gameState.pucksTotal++;
  updateGameDisplay();
  await saveGameStateToCloud();
});

document.getElementById('manualPrize').addEventListener('click', async () => {
  const prizeName = prompt('Enter prize name:');
  if (prizeName) {
    gameState.prizesWon.push({
      board: gameState.currentBoard,
      prize: prizeName,
      symbol: 'üéÅ',
      timestamp: Date.now(),
      manual: true
    });
    updateGameDisplay();
    await saveGameStateToCloud();
  }
});

document.getElementById('switchBoard').addEventListener('click', async () => {
  gameState.currentBoard = gameState.currentBoard === 'A' ? 'B' : 'A';
  updateBoardDisplay();
  initPegs();
  await saveGameStateToCloud();
  drawBoard();
});

document.getElementById('copyGameLink').addEventListener('click', () => {
  if (!gameState.gameId) {
    alert('No active game to copy link for');
    return;
  }
  
  const gameLink = `${window.location.origin}${window.location.pathname}?game=${gameState.gameId}&admin=true`;
  navigator.clipboard.writeText(gameLink).then(() => {
    alert('Game link copied to clipboard!');
  });
});

// ==================== INITIALIZE LEGENDS ====================
function initializeLegends() {
  // Board A legend
  const legendA = document.getElementById('legendA');
  const uniquePrizesA = [];
  
  gameState.boards.A.prizes.forEach(prize => {
    if (!uniquePrizesA.find(p => p.symbol === prize.symbol)) {
      uniquePrizesA.push(prize);
    }
  });
  
  uniquePrizesA.forEach(prize => {
    const item = document.createElement('div');
    item.className = 'legend-item';
    item.innerHTML = `
      <div class="legend-symbol" style="background: ${prize.color}">${prize.symbol}</div>
      <div class="legend-text">${prize.name}</div>
    `;
    legendA.appendChild(item);
  });
  
  // Board B legend
  const legendB = document.getElementById('legendB');
  const uniquePrizesB = [];
  
  gameState.boards.B.prizes.forEach(prize => {
    if (!uniquePrizesB.find(p => p.symbol === prize.symbol)) {
      uniquePrizesB.push(prize);
    }
  });
  
  uniquePrizesB.forEach(prize => {
    const item = document.createElement('div');
    item.className = 'legend-item';
    item.innerHTML = `
      <div class="legend-symbol" style="background: ${prize.color}">${prize.symbol}</div>
      <div class="legend-text">${prize.name}</div>
    `;
    legendB.appendChild(item);
  });
}

// ==================== URL PARAMETERS ====================
function checkUrlParameters() {
  const urlParams = new URLSearchParams(window.location.search);
  const gameId = urlParams.get('game');
  const isAdmin = urlParams.get('admin') === 'true';
  
  if (gameId) {
    if (isAdmin) {
      document.querySelector('.mode-btn[data-mode="admin"]').click();
      document.getElementById('gameIdInput').value = gameId;
      setTimeout(() => {
        document.getElementById('connectToGame').click();
      }, 500);
    } else {
      // Auto-connect as player
      gameState.gameId = gameId;
      loadGameStateFromCloud(gameId);
    }
  }
}

// ==================== INITIALIZATION ====================
initializeLegends();
initPegs();
drawBoard();
checkUrlParameters();
updateConnectionStatus();

// Set default board selection
document.querySelector('.board-option[data-board="A"]').classList.add('selected');

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  stopSyncInterval();
});
</script>
</body>
</html>
